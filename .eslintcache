[{"/Users/abraham/Data-structures-editor/src/index.js":"1","/Users/abraham/Data-structures-editor/src/App.js":"2","/Users/abraham/Data-structures-editor/src/dataStructures/Graph.js":"3","/Users/abraham/Data-structures-editor/src/dataStructures/Trie.js":"4","/Users/abraham/Data-structures-editor/src/drawableComponents/Edge.js":"5","/Users/abraham/Data-structures-editor/src/drawableComponents/Node.js":"6","/Users/abraham/Data-structures-editor/src/drawableComponents/Rectangle.js":"7","/Users/abraham/Data-structures-editor/src/dataStructures/Vector.js":"8","/Users/abraham/Data-structures-editor/src/dataStructures/Matrix.js":"9","/Users/abraham/Data-structures-editor/src/dataStructures/Stack.js":"10","/Users/abraham/Data-structures-editor/src/utils/Utils.js":"11","/Users/abraham/Data-structures-editor/src/algorithms/Geometry.js":"12","/Users/abraham/Data-structures-editor/src/components/Canvas.js":"13","/Users/abraham/Data-structures-editor/src/utils/TextParser.js":"14","/Users/abraham/Data-structures-editor/src/utils/DataStructuresIdentifier.js":"15","/Users/abraham/Data-structures-editor/src/utils/CppIdentifier.js":"16","/Users/abraham/Data-structures-editor/src/dataStructures/Queue.js":"17","/Users/abraham/Data-structures-editor/src/drawableComponents/EmptyDataStructure.js":"18","/Users/abraham/Data-structures-editor/src/dataStructures/Deque.js":"19","/Users/abraham/Data-structures-editor/src/drawableComponents/Text.js":"20","/Users/abraham/Data-structures-editor/src/dataStructures/Indices.js":"21","/Users/abraham/Data-structures-editor/src/dataStructures/STLIndices.js":"22"},{"size":152,"mtime":1671550730802,"results":"23","hashOfConfig":"24"},{"size":3398,"mtime":1672284780580,"results":"25","hashOfConfig":"24"},{"size":4056,"mtime":1672237391925,"results":"26","hashOfConfig":"24"},{"size":882,"mtime":1672237391934,"results":"27","hashOfConfig":"24"},{"size":3588,"mtime":1672237458260,"results":"28","hashOfConfig":"24"},{"size":2397,"mtime":1672237391925,"results":"29","hashOfConfig":"24"},{"size":727,"mtime":1672245405362,"results":"30","hashOfConfig":"24"},{"size":2006,"mtime":1672320335671,"results":"31","hashOfConfig":"24"},{"size":1495,"mtime":1672321707260,"results":"32","hashOfConfig":"24"},{"size":1047,"mtime":1672321950303,"results":"33","hashOfConfig":"24"},{"size":2772,"mtime":1672283387523,"results":"34","hashOfConfig":"24"},{"size":938,"mtime":1671550730800,"results":"35","hashOfConfig":"24"},{"size":2210,"mtime":1672321898560,"results":"36","hashOfConfig":"24"},{"size":10013,"mtime":1672319908666,"results":"37","hashOfConfig":"24"},{"size":836,"mtime":1672285091171,"results":"38","hashOfConfig":"24"},{"size":460,"mtime":1672239238900,"results":"39","hashOfConfig":"24"},{"size":219,"mtime":1672321716243,"results":"40","hashOfConfig":"24"},{"size":351,"mtime":1672245291807,"results":"41","hashOfConfig":"24"},{"size":304,"mtime":1672282740615,"results":"42","hashOfConfig":"24"},{"size":383,"mtime":1672321593391,"results":"43","hashOfConfig":"24"},{"size":1780,"mtime":1672321926313,"results":"44","hashOfConfig":"24"},{"size":1875,"mtime":1672321969214,"results":"45","hashOfConfig":"24"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"10hd212",{"filePath":"49","messages":"50","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"48"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"48"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"48"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"48"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"48"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/abraham/Data-structures-editor/src/index.js",[],["96","97"],"/Users/abraham/Data-structures-editor/src/App.js",["98"],"import React, { useEffect, useState } from 'react';\nimport \"./styles.css\"\n\nimport Canvas from \"./components/Canvas\";\nimport Text from \"./drawableComponents/Text\";\n\nimport { TextParser } from './utils/TextParser';\nimport { TEXT_SPACE } from './utils/Utils';\n\nconst placeholderText =\n  \"[color]\\nChanges all elements below with this color within the same data structure\\n\\n\" +\n  \"[command] Optional command, if not added that's the default behaviour or is an optional style \\n\\n\" +\n  \"-------\\n\\n\" +\n  \"Array | Vector [name]\\n\" +\n  \"[push_back] value [color]\\n\" +\n  \"pop_back\\n\\n\\n\" +\n  \"\" +\n  \"Matrix [name]\\n\" +\n  \"mat[1,1] mat[1,2] ... mat[1, c]\\n\" +\n  \"mat[2,1] mat[2,2] ...\\n...\\n\" +\n  \"mat[r,1] [color]\\n\\n\\n\" +\n  \"\" +\n  \"Stack | Queue [name]\\n\" +\n  \"[push] value [color]\\n\" +\n  \"pop\\n\\n\\n\" +\n  \"\" +\n  \"Deque [name]\\n\" +\n  \"[push_back] value [color]\\n\" +\n  \"push_front value [color]\\n\" +\n  \"pop_back\\n\" +\n  \"pop_front\\n\\n\\n\" +\n  \"\" +\n  // \"Graph\\n\" +\n  // \"u [color] (add node)\\n\" +\n  // \"u v [weight] [color] [dash] (add edge)\\n\\n\" +\n  // \"Trie\\n\" +\n  // \"word [color]\\n...\\n\\n\" +\n  \"\";\n\n\nconst arrayExample = \"array Arreglo\\n\" +\n  \"1 -20000 3\\n\" +\n  \"blue\\n\" +\n  \"4 -0.0005 600\\n\" +\n  \"orange\\n\" +\n  \"7 80 9000 10 purple 11 12 red\\n\" +\n  \"sort\\n\" +\n  \"reverse\\n\\n\";\n\nconst matrixExample = \"matrix Matriz colorida\\n\" +\n  \"1 2 3\\n\" +\n  \"red\\n\" +\n  \"4 5 orange 6\\n\" +\n  \"7 purple 8 9 pink\\n\" +\n  \"blue\\n\" +\n  \"10 11 12\\n\\n\";\n\nconst stackExample = \"stack Pila\\n\" +\n  \"push 1\\n\" +\n  \"push 2 blue\\n\" +\n  \"push 3\\n\" +\n  \"4\\n\" +\n  \"pop\\n\" +\n  \"pop\\n\" +\n  \"5 red\\n\" +\n  \"orange\\n\" +\n  \"6\\n\" +\n  \"7\\n\\n\";\n\nconst queueExample = \"queue Cola\\n\" +\n  \"push 1\\n\" +\n  \"push 2 blue\\n\" +\n  \"push 3\\n\" +\n  \"4\\n\" +\n  \"pop\\n\" +\n  \"pop\\n\" +\n  \"5 red\\n\" +\n  \"orange\\n\" +\n  \"6\\n\" +\n  \"7\\n\\n\";\n\nconst dequeExample =\n  \"deque Cola mamalona\\n\" +\n  \"push_back 1\\n\" +\n  \"push_back 2\\n\" +\n  \"push_front 3\\n\" +\n  \"push_front 4\\n\" +\n  \"push_front 5\\n\" +\n  \"push_back 6\\n\" +\n  \"push_back 7\\n\" +\n  \"pop_front\\n\" +\n  \"pop_back\\n\" +\n  \"pop_front\\n\\n\"\n\nconst example = arrayExample + matrixExample + stackExample + queueExample + dequeExample;\n\nexport default function App() {\n  const [text, setText] = useState(example);\n  const [parser, setParser] = useState(new TextParser(\"\"));\n\n  useEffect(() => {\n    const newParser = new TextParser(text, parser);\n    setParser(newParser);\n    console.log(newParser.objects);\n  }, [text]);\n\n  return (\n    <div class=\"global-div\">\n      {/* <div>\n        <button>\n          {\"Drawing a \" + (this.state.drawGraph ? \"graph\" : \"trie\")}\n        </button>\n\n        <button>\n          {likeTree ? \"ordered as a tree\" : \"randomly ordered\"}\n        </button>\n\n        <button>\n          {directed ? \"directed\" : \"un-directed\"}\n        </button>\n\n        <button>\n          {\"drag \" + (drag ? \"all\" : \"a single node\")}\n        </button>\n      </div> */}\n\n      <div class=\"image-wrapper\">\n        <textarea\n          type=\"text\"\n          className=\"input\"\n          value={text}\n          onChange={(e) => setText(e.target.value)}\n          placeholder={placeholderText}\n        />\n\n        <Canvas\n          objects={parser.objects.map((object) => [\n            object.draw,\n            object.name ? <Text\n              x={object.left - TEXT_SPACE}\n              y={object.top - TEXT_SPACE}\n              text={`${object.name}:`} /> : null\n          ])}\n        />\n      </div>\n    </div>\n  );\n}","/Users/abraham/Data-structures-editor/src/dataStructures/Graph.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Trie.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/Edge.js",["99","100"],"import React from \"react\"\nimport { NaturalCurve } from \"react-svg-curve\"\nimport { length, dif, sum, mul, divide, unit, perp, rotate, projectionOnCircle } from \"../algorithms/Geometry\";\n\nexport function Edge({ rank, from, to, weight, color, directed, dashedLine }) {\n  const radius = 25;\n\n  let bothEndpoints = (from !== undefined && to !== undefined);\n  let midPoint = { x: 0, y: 0 };\n  let fromOnCircle = { x: 0, y: 0 };\n  let toOnCircle = { x: 0, y: 0 };\n\n  if (bothEndpoints) {\n    let half = divide(sum(from, to), 2);\n    let dirHalfPerp = unit(perp(dif(from, half)))\n    midPoint = sum(half, mul(dirHalfPerp, -40 * rank));\n\n    fromOnCircle = projectionOnCircle(from, radius, midPoint);\n    toOnCircle = projectionOnCircle(to, radius, midPoint);\n  }\n\n  function getArrow() {\n    let dir = unit(dif(midPoint, toOnCircle));\n\n    // let p = sum(toOnCircle, mul(dir, radius));\n    let start = toOnCircle;\n    let end = sum(toOnCircle, mul(dir, 10));\n    let perpQ = unit(perp(dif(start, end)));\n    let perp1 = sum(end, mul(perpQ, 5));\n    let perp2 = sum(end, mul(perpQ, -5));\n\n    let str =\n      \" M \" + start.x + \",\" + start.y +\n      \" \" + perp1.x + \", \" + perp1.y +\n      \" \" + perp2.x + \" \" + perp2.y + \" z \";\n    // console.log(str);\n\n    return str;\n  }\n\n  const boldEdge = (color === \"black\" ? 1.5 : 3);\n  const dash = dashedLine ? 5 : 0;\n\n  return (\n    <g>\n      {\n        bothEndpoints &&\n        <NaturalCurve\n          data={[\n            [fromOnCircle.x, fromOnCircle.y],\n            [midPoint.x, midPoint.y],\n            [toOnCircle.x, toOnCircle.y],\n          ]}\n          stroke={color}\n          strokeWidth={boldEdge}\n          strokeDasharray={dash}\n          showPoints={false} />\n      }\n\n      {\n        (bothEndpoints && directed) &&\n        <path\n          d={getArrow()}\n          fill={color}\n          stroke={color} />\n      }\n\n      {\n        (bothEndpoints && weight) &&\n        <text\n          x={midPoint.x + 10}\n          y={midPoint.y + 10}\n          fill=\"black\" >\n          {weight}\n        </text>\n      }\n    </g>\n  );\n}\n\nexport function Loop({ from, to, weight, color, directed }) {\n  let bothEndpoints = (from !== undefined && to !== undefined);\n\n  let textPos = { x: 0, y: 0 };\n  if (bothEndpoints) {\n    textPos.x = (from.x + to.x) / 2;\n    textPos.y = (from.y + to.y) / 2;\n  }\n\n  const boldEdge = (color === \"black\" ? 1.5 : 3);\n  const dx = 0;\n  const dy = -35;\n\n  function getArrow() {\n    let loopOutside = {\n      x: from.x + 20,\n      y: from.y + dy\n    };\n\n    let dir = unit(dif(loopOutside, from));\n\n    let p = {\n      x: loopOutside.x - 5.5,\n      y: loopOutside.y + 13.5\n    };\n    let q = sum(p, mul(dir, 8));\n\n    let perpQ = unit(perp(dif(p, q)));\n    let perp1 = sum(q, mul(perpQ, 5));\n    let perp2 = sum(q, mul(perpQ, -5));\n\n    let str =\n      \" M \" + p.x + \",\" + p.y +\n      \" \" + perp1.x + \", \" + perp1.y +\n      \" \" + perp2.x + \" \" + perp2.y + \" z \";\n    // console.log(str);\n\n    return str;\n  }\n\n  console.log(from.x, from.y);\n\n  return (\n    <g>\n      {\n        bothEndpoints &&\n        <circle\n          cx={from.x + dx}\n          cy={from.y + dy}\n          r={20}\n          fill=\"none\"\n          stroke={color}\n          strokeWidth={boldEdge}\n        />\n      }\n\n      {\n        (bothEndpoints && directed) &&\n        <path\n          d={getArrow()}\n          fill={color}\n          stroke={color} />\n      }\n\n      {\n        (bothEndpoints && weight) &&\n        <text\n          x={textPos.x + dx}\n          y={textPos.y + 1.8 * dy}\n          fill=\"black\" >\n          {weight}\n        </text>\n      }\n    </g>\n  );\n}","/Users/abraham/Data-structures-editor/src/drawableComponents/Node.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/Rectangle.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Vector.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Matrix.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Stack.js",[],"/Users/abraham/Data-structures-editor/src/utils/Utils.js",["101"],"export const DEFAULT_NODE_COLOR = \"#c9a9ff\";\nexport const BLACK = \"black\";\n\nexport const BLOCK_HEIGHT = 45;\nexport const TEXT_SPACE = 20;\nexport const SPACE = 10;\nexport const BLOCK_WITH_VERTICAL_SPACE_HEIGHT = BLOCK_HEIGHT + SPACE;\nexport const VERTICAL_DISTANCE = 80;\n\nexport function getRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function isNumeric(num) {\n  return !isNaN(num)\n}\n\nexport function isColor(x) {\n  x = x.toLowerCase();\n  let s = new Option().style\n  s.color = x\n  let test1 = s.color === x\n  let test2 = /^#[0-9A-F]{6}$/i.test(x)\n  return (test1 === true || test2 === true)\n}\n\nexport function isDash(x) {\n  x = x.toLowerCase();\n  return x === \"dash\";\n}\n\nexport function isSpace(c) {\n  return (c === ' ') || (c === '\\t');\n}\n\nexport function divideByTokens(str) {\n  let result = [];\n  let last = \"\";\n  for (let i in str) {\n    let c = str[i];\n    if (isSpace(c)) {\n      if (last !== \"\") {\n        result.push(last.trim());\n      }\n      last = \"\";\n    } else {\n      last += c;\n    }\n  }\n  if (last !== \"\") {\n    result.push(last.trim());\n  }\n  return result;\n}\n\nexport function isLight(col) {\n  let cur = col.charAt(0) === '#' ? col.substring(1, 7) : col;\n  let r = parseInt(cur.substring(0, 2), 16); // hexToR\n  let g = parseInt(cur.substring(2, 4), 16); // hexToG\n  let b = parseInt(cur.substring(4, 6), 16); // hexToB\n  return (((r * 0.299) + (g * 0.587) + (b * 0.114)) > 186);\n}\n\nexport function pickTextColor(color) {\n  return isLight(color) ? \"black\" : \"white\";\n}\n\nfunction getRGB(rgb) {\n  let el = document.createElement(\"div\");\n  el.style[\"background-color\"] = rgb;\n  document.body.appendChild(el);\n\n  let style = window.getComputedStyle(el);\n  let color = style[\"backgroundColor\"];\n  document.body.removeChild(el);\n\n  return color;\n}\n\nfunction parseColor(color) {\n  let arr = [];\n  color.replace(/[\\d+\\.]+/g, function (v) {\n    arr.push(parseFloat(v));\n  });\n  return \"#\" + arr.slice(0, 3).map(toHex).join(\"\");\n}\n\nfunction toHex(int) {\n  let hex = int.toString(16);\n  return hex.length === 1 ? \"0\" + hex : hex;\n}\n\nexport function lightenColor(col, amt) {\n  if (col.charAt(0) !== '#') {\n    col = parseColor(getRGB(col));\n  }\n\n  let cur = col.charAt(0) === '#' ? col.substring(1, 7) : col;\n\n  let r = Math.max(Math.min(255, parseInt(cur.substring(0, 2), 16) + amt), 0).toString(16)\n  let g = Math.max(Math.min(255, parseInt(cur.substring(2, 4), 16) + amt), 0).toString(16)\n  let b = Math.max(Math.min(255, parseInt(cur.substring(4, 6), 16) + amt), 0).toString(16)\n\n  const rr = (r.length < 2 ? '0' : '') + r\n  const gg = (g.length < 2 ? '0' : '') + g\n  const bb = (b.length < 2 ? '0' : '') + b\n  return `#${rr}${gg}${bb}`\n}\n\nexport function getWidthFromText(text) {\n  return Math.max(BLOCK_HEIGHT, text.length * 15);\n}","/Users/abraham/Data-structures-editor/src/algorithms/Geometry.js",[],"/Users/abraham/Data-structures-editor/src/components/Canvas.js",["102","103","104","105","106","107","108"],"import React, { useState, useCallback, useEffect } from \"react\";\n\nconst MAX_ZOOM = 4;\nconst MIN_ZOOM = 0.3;\nconst ZOOM_INCREMENT = 0.25;\n\nexport default function Canvas({ objects }) {\n  const [zoom, setZoom] = useState(1.5);\n  const [dragging, setDragging] = useState(false);\n  const [top, setTop] = useState(0);\n  const [left, setLeft] = useState(50);\n  const [relativeTop, setRelativeTop] = useState(0);\n  const [relativeLeft, setRelativeLeft] = useState(0);\n  const [windowWidth, setWindowWidth] = useState(Number(window.innerWidth));\n  const [windowHeight, setWindowHeight] = useState(Number(window.innerHeight));\n\n  const mouseDown = useCallback((e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    if (e.button !== 0) {\n      return; // Should only run code from left mouse click\n    }\n    // console.log(\"mouseDown\", e.pageX, e.pageY, e);\n    setDragging(true);\n    setRelativeLeft(e.pageX - left);\n    setRelativeTop(e.pageY - top);\n  }, [left, top]);\n\n  const mouseUp = useCallback((e) => {\n    // console.log(\"mouseUp\");\n    e.stopPropagation();\n    e.preventDefault();\n    setDragging(false);\n  }, []);\n\n  const moveMouse = useCallback((e) => {\n    // console.log(\"moveMouse\");\n    e.stopPropagation();\n    e.preventDefault();\n    if (!dragging) {\n      return;\n    }\n    setLeft(e.pageX - relativeLeft);\n    setTop(e.pageY - relativeTop);\n  }, [dragging]);\n\n  useEffect(() => {\n    // console.log(left, top, dragging);\n\n    document.addEventListener('mousemove', moveMouse);\n    document.addEventListener('mouseup', mouseUp);\n    // window.addEventListener('resize', updateWindowDimensions);\n    return () => {\n      document.removeEventListener('mousemove', moveMouse);\n      document.removeEventListener('mouseup', mouseUp);\n      // window.removeEventListener('resize', updateWindowDimensions);\n    };\n  }, [moveMouse, mouseUp, mouseDown]);\n\n  return (\n    <div className=\"scrollable-image\">\n      <svg className=\"image\"\n        viewBox={`${-left} ${-top} ${windowWidth} ${windowHeight}`}\n        onMouseDown={mouseDown}\n        onMouseUp={mouseUp}\n        onMouseMove={moveMouse}>\n        <g transform={`scale(${zoom})`}>\n          {objects}\n        </g>\n      </svg>\n    </div>\n  );\n}","/Users/abraham/Data-structures-editor/src/utils/TextParser.js",["109","110"],"import { isNumeric, isColor, divideByTokens, VERTICAL_DISTANCE, BLOCK_HEIGHT } from \"./Utils\";\n\nimport { Graph } from \"../dataStructures/Graph\";\nimport { Trie } from \"../dataStructures/Trie\";\nimport { Sides, Vector } from \"../dataStructures/Vector\";\nimport { Matrix } from \"../dataStructures/Matrix\";\nimport { Stack } from \"../dataStructures/Stack\";\nimport { Queue } from \"../dataStructures/Queue\";\nimport { Deque } from \"../dataStructures/Deque\";\n\nimport { DataStructuresIdentifier } from \"./DataStructuresIdentifier\";\nimport { CppIdentifier } from \"./CppIdentifier\";\nimport { Indices } from \"../dataStructures/Indices\";\nimport { STLIndices } from \"../dataStructures/STLIndices\";\n\nexport class TextParser {\n  constructor(text, oldParser = null) {\n    const lines = text.split('\\n').filter((line) => {\n      return line.length > 0;\n    });\n\n    this.textObjects = this.splitInTextObjects(lines);\n\n    this.objects = [];\n    this.lastTop = 0;\n    let objectCount = new Map();\n    this.textObjects.forEach((element, index) => {\n      let object = this.getObject(element, null);\n      this.lastTop += object.height;\n      this.lastTop += VERTICAL_DISTANCE;\n\n      if (element.name) {\n        object.name = element.name;\n      } else {\n        const id = (objectCount.get(object.name) ?? 0) + 1;\n        objectCount.set(object.name, id);\n        object.name += \" \" + id;\n      }\n\n      this.objects.push(object);\n\n      // add indices if is a vector, array or matrix\n      if (DataStructuresIdentifier.isVector(element.type) ||\n        DataStructuresIdentifier.isMatrix(element.type)) {\n        this.objects.push(new Indices(element.type, object));\n      }\n\n      // add top, bottom, front, back if is a stack, queue, deque\n      if (DataStructuresIdentifier.isStack(element.type) ||\n        DataStructuresIdentifier.isQueue(element.type) ||\n        DataStructuresIdentifier.isDeque(element.type)) {\n        this.objects.push(new STLIndices(element.type, object));\n      }\n    });\n  }\n\n  getObject(element, previousObject = null) {\n    if (DataStructuresIdentifier.isVector(element.type)) {\n      return this.getVector(element.lines);\n    } else if (DataStructuresIdentifier.isMatrix(element.type)) {\n      return this.getMatrix(element.lines);\n    } else if (DataStructuresIdentifier.isStack(element.type)) {\n      return this.getStack(element.lines);\n    } else if (DataStructuresIdentifier.isQueue(element.type)) {\n      return this.getQueue(element.lines);\n    } else if (DataStructuresIdentifier.isDeque(element.type)) {\n      return this.getDeque(element.lines);\n    } else if (DataStructuresIdentifier.isGraph(element.type)) {\n      return this.getGraph(element.lines, null);\n    } else if (DataStructuresIdentifier.isTrie(element.type)) {\n      return this.getTrie(element.lines);\n    }\n    return null;\n  }\n\n  getNameIfAny(line) {\n    let tokens = divideByTokens(line);\n    tokens.shift();\n    return tokens.join(\" \");\n  }\n\n  splitInTextObjects(lines) {\n    // Objets are in the form [{ object type, lines of text }]\n    let objects = [];\n    let start = -1;\n    for (let pos = 0; pos <= lines.length; pos++) {\n      if (pos === lines.length || DataStructuresIdentifier.isObject(lines[pos])) {\n        if (start !== -1) {\n          objects.push({\n            type: divideByTokens(lines[start].toLowerCase()).shift(),\n            name: this.getNameIfAny(lines[start]),\n            lines: lines.slice(start + 1, pos).map((line) => {\n              return divideByTokens(line);\n            }),\n          });\n        }\n        start = pos;\n      }\n    }\n    return objects;\n  }\n\n  getVector(lines) {\n    const vector = new Vector(this.lastTop);\n\n    let sortArray = false;\n    let reverseArray = false;\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        vector.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (element === \"sort\") {\n          sortArray = true;\n        } else if (element === \"reverse\") {\n          reverseArray = !reverseArray;\n        } else if (isColor(element)) {\n          // update color of the last element if any\n          vector.updateLastElementColor(element);\n        } else if (CppIdentifier.isPushBack(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPopBack(element)) {\n          vector.popBack();\n        } else {\n          vector.pushBack(element);\n        }\n      }\n    }\n\n    if (sortArray) {\n      vector.data.sort((a, b) => {\n        if (isNumeric(a.value)) {\n          if (isNumeric(b.value)) {\n            return a.value - b.value;\n          } else {\n            return a.value < b.value;\n          }\n        } else {\n          return a.value < b.value;\n        }\n      });\n    }\n\n    if (reverseArray) {\n      vector.data.reverse();\n    }\n\n    return vector;\n  }\n\n  getMatrix(lines) {\n    const matrix = new Matrix(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        matrix.currentColor = line[0];\n        continue;\n      }\n\n      let newRowAdded = false;\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          matrix.updateLastElementColor(element);\n        } else {\n          if (!newRowAdded) {\n            matrix.addRow();\n            newRowAdded = true;\n          }\n          matrix.lastRowPushBack(element);\n        }\n      }\n    }\n\n    if (matrix.empty()) {\n      matrix.height = BLOCK_HEIGHT;\n    }\n\n    return matrix;\n  }\n\n  getQueue(lines) {\n    const queue = new Queue(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        queue.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          queue.updateLastElementColor(element);\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPop(element)) {\n          queue.pop();\n        } else {\n          queue.push(element);\n        }\n      }\n    }\n\n    return queue;\n  }\n\n  getStack(lines) {\n    const stack = new Stack(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        stack.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          stack.updateLastElementColor(element);\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPop(element)) {\n          stack.pop();\n        } else {\n          stack.push(element);\n        }\n      }\n    }\n\n    return stack;\n  }\n\n  getDeque(lines) {\n    const deque = new Deque(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        deque.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          deque.updateLastElementColor(element);\n        } else if (CppIdentifier.isPushBack(element)) {\n          deque.side = Sides.BACK;\n        } else if (CppIdentifier.isPushFront(element)) {\n          deque.side = Sides.FRONT;\n        } else if (CppIdentifier.isPopBack(element)) {\n          deque.popBack();\n        } else if (CppIdentifier.isPopFront(element)) {\n          deque.popFront();\n        } else {\n          deque.push(element);\n        }\n      }\n    }\n\n    return deque;\n  }\n\n  // getGraph(lines, previousGraph) {\n  //   const graph = new Graph(false, previousGraph);\n\n  //   for (const line of lines) {\n  //     if (line.length === 1) {\n  //       const x = line[0];\n  //       if (isColor(x)) {\n  //         // paint everything that's below with this color\n  //         graph.currentNodeColor = x;\n  //       } else {\n  //         // Single node\n  //         const u = line[0];\n  //         graph.addNode(u, {});\n  //       }\n  //     } else if (line.length === 2) {\n  //       const u = line[0];\n  //       const x = line[1];\n  //       if (isColor(x)) {\n  //         // Node with color x\n  //         graph.addNode(u, { color: x });\n  //       } else {\n  //         // Edge u -> v (depends on the flag)\n  //         const v = line[1];\n  //         graph.addEdge(u, v, \"\");\n  //       }\n  //     } else if (line.length >= 3) {\n  //       const u = line[0];\n  //       const v = line[1];\n\n  //       // Edge u -> v with color | weight | dash\n  //       let weight = \"\";\n  //       let color = \"black\";\n  //       let dashedLine = false;\n  //       for (let i = 2; i < line.length; i++) {\n  //         const x = line[i];\n  //         if (isColor(x)) {\n  //           color = x;\n  //         } else if (isDash(x)) {\n  //           dashedLine = true;\n  //         } else {\n  //           weight += x + \" \";\n  //         }\n  //       }\n\n  //       graph.addEdge(u, v, weight, color, dashedLine);\n  //     }\n  //   }\n\n  //   return graph;\n  // }\n\n  // getTrie(lines) {\n  //   const trie = new Trie(addNode, addEdge);\n  //   currentNodeColor = \"red\";\n  //   for (const line of lines) {\n  //     if (object.length === 1) {\n  //       if (isColor(object[0])) {\n  //         // change the color of all below nodes\n  //         currentNodeColor = object[0];\n  //       } else {\n  //         // insert a word with the currentNodeColor\n  //         const word = object[0];\n  //         trie.insert(word, currentNodeColor);\n  //       }\n  //     } else if (object.length === 2) {\n  //       // insert a word with possibly a custom color\n  //       const word = object[0];\n  //       let color = currentNodeColor;\n  //       if (object.length === 2 && isColor(object[1])) {\n  //         color = object[1];\n  //       }\n  //       trie.insert(word, color);\n  //     }\n  //   }\n  //   trie.dfs(trie.root, \"*\");\n  // }\n}","/Users/abraham/Data-structures-editor/src/utils/DataStructuresIdentifier.js",[],"/Users/abraham/Data-structures-editor/src/utils/CppIdentifier.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Queue.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/EmptyDataStructure.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Deque.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/Text.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Indices.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/STLIndices.js",[],{"ruleId":"111","replacedBy":"112"},{"ruleId":"113","replacedBy":"114"},{"ruleId":"115","severity":1,"message":"116","line":105,"column":6,"nodeType":"117","endLine":105,"endColumn":12,"suggestions":"118"},{"ruleId":"119","severity":1,"message":"120","line":3,"column":10,"nodeType":"121","messageId":"122","endLine":3,"endColumn":16},{"ruleId":"119","severity":1,"message":"123","line":3,"column":53,"nodeType":"121","messageId":"122","endLine":3,"endColumn":59},{"ruleId":"124","severity":1,"message":"125","line":82,"column":22,"nodeType":"126","messageId":"127","endLine":82,"endColumn":23,"suggestions":"128"},{"ruleId":"119","severity":1,"message":"129","line":3,"column":7,"nodeType":"121","messageId":"122","endLine":3,"endColumn":15},{"ruleId":"119","severity":1,"message":"130","line":4,"column":7,"nodeType":"121","messageId":"122","endLine":4,"endColumn":15},{"ruleId":"119","severity":1,"message":"131","line":5,"column":7,"nodeType":"121","messageId":"122","endLine":5,"endColumn":21},{"ruleId":"119","severity":1,"message":"132","line":8,"column":16,"nodeType":"121","messageId":"122","endLine":8,"endColumn":23},{"ruleId":"119","severity":1,"message":"133","line":14,"column":23,"nodeType":"121","messageId":"122","endLine":14,"endColumn":37},{"ruleId":"119","severity":1,"message":"134","line":15,"column":24,"nodeType":"121","messageId":"122","endLine":15,"endColumn":39},{"ruleId":"115","severity":1,"message":"135","line":45,"column":6,"nodeType":"117","endLine":45,"endColumn":16,"suggestions":"136"},{"ruleId":"119","severity":1,"message":"137","line":3,"column":10,"nodeType":"121","messageId":"122","endLine":3,"endColumn":15},{"ruleId":"119","severity":1,"message":"138","line":4,"column":10,"nodeType":"121","messageId":"122","endLine":4,"endColumn":14},"no-native-reassign",["139"],"no-negated-in-lhs",["140"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'parser'. Either include it or remove the dependency array.","ArrayExpression",["141"],"no-unused-vars","'length' is defined but never used.","Identifier","unusedVar","'rotate' is defined but never used.","no-useless-escape","Unnecessary escape character: \\..","Literal","unnecessaryEscape",["142","143"],"'MAX_ZOOM' is assigned a value but never used.","'MIN_ZOOM' is assigned a value but never used.","'ZOOM_INCREMENT' is assigned a value but never used.","'setZoom' is assigned a value but never used.","'setWindowWidth' is assigned a value but never used.","'setWindowHeight' is assigned a value but never used.","React Hook useCallback has missing dependencies: 'relativeLeft' and 'relativeTop'. Either include them or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setLeft' needs the current value of 'relativeLeft'.",["144"],"'Graph' is defined but never used.","'Trie' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"145","fix":"146"},{"messageId":"147","fix":"148","desc":"149"},{"messageId":"150","fix":"151","desc":"152"},{"desc":"153","fix":"154"},"Update the dependencies array to be: [parser, text]",{"range":"155","text":"156"},"removeEscape",{"range":"157","text":"158"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"159","text":"160"},"Replace the `\\` with `\\\\` to include the actual backslash character.","Update the dependencies array to be: [dragging, relativeLeft, relativeTop]",{"range":"161","text":"162"},[2390,2396],"[parser, text]",[1856,1857],"",[1856,1856],"\\",[1365,1375],"[dragging, relativeLeft, relativeTop]"]