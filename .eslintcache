[{"/Users/abraham/Data-structures-editor/src/index.js":"1","/Users/abraham/Data-structures-editor/src/App.js":"2","/Users/abraham/Data-structures-editor/src/dataStructures/Graph.js":"3","/Users/abraham/Data-structures-editor/src/dataStructures/Trie.js":"4","/Users/abraham/Data-structures-editor/src/drawableComponents/Edge.js":"5","/Users/abraham/Data-structures-editor/src/drawableComponents/Node.js":"6","/Users/abraham/Data-structures-editor/src/drawableComponents/Rectangle.js":"7","/Users/abraham/Data-structures-editor/src/dataStructures/Vector.js":"8","/Users/abraham/Data-structures-editor/src/dataStructures/Matrix.js":"9","/Users/abraham/Data-structures-editor/src/dataStructures/Stack.js":"10","/Users/abraham/Data-structures-editor/src/utils/Utils.js":"11","/Users/abraham/Data-structures-editor/src/algorithms/Geometry.js":"12","/Users/abraham/Data-structures-editor/src/components/Canvas.js":"13","/Users/abraham/Data-structures-editor/src/utils/TextParser.js":"14","/Users/abraham/Data-structures-editor/src/utils/DataStructuresIdentifier.js":"15","/Users/abraham/Data-structures-editor/src/utils/CppIdentifier.js":"16","/Users/abraham/Data-structures-editor/src/dataStructures/Queue.js":"17","/Users/abraham/Data-structures-editor/src/drawableComponents/EmptyDataStructure.js":"18","/Users/abraham/Data-structures-editor/src/dataStructures/Deque.js":"19","/Users/abraham/Data-structures-editor/src/drawableComponents/Text.js":"20","/Users/abraham/Data-structures-editor/src/dataStructures/Indices.js":"21","/Users/abraham/Data-structures-editor/src/dataStructures/STLIndices.js":"22","/Users/abraham/Data-structures-editor/src/dataStructures/Heap.js":"23","/Users/abraham/Data-structures-editor/src/algorithms/Buchheim.js":"24","/Users/abraham/Data-structures-editor/src/dataStructures/STLMap.js":"25","/Users/abraham/Data-structures-editor/src/dataStructures/STLSet.js":"26"},{"size":152,"mtime":1671550730802,"results":"27","hashOfConfig":"28"},{"size":3987,"mtime":1672788995656,"results":"29","hashOfConfig":"28"},{"size":3679,"mtime":1672760964884,"results":"30","hashOfConfig":"28"},{"size":882,"mtime":1672760964878,"results":"31","hashOfConfig":"28"},{"size":3588,"mtime":1672237458260,"results":"32","hashOfConfig":"28"},{"size":2817,"mtime":1672789580359,"results":"33","hashOfConfig":"28"},{"size":727,"mtime":1672245405362,"results":"34","hashOfConfig":"28"},{"size":2006,"mtime":1672760964884,"results":"35","hashOfConfig":"28"},{"size":1474,"mtime":1672760964884,"results":"36","hashOfConfig":"28"},{"size":1026,"mtime":1672497484296,"results":"37","hashOfConfig":"28"},{"size":2989,"mtime":1672771305222,"results":"38","hashOfConfig":"28"},{"size":938,"mtime":1671550730800,"results":"39","hashOfConfig":"28"},{"size":2492,"mtime":1672322055363,"results":"40","hashOfConfig":"28"},{"size":13521,"mtime":1672787411702,"results":"41","hashOfConfig":"28"},{"size":1137,"mtime":1672760693031,"results":"42","hashOfConfig":"28"},{"size":810,"mtime":1672783881439,"results":"43","hashOfConfig":"28"},{"size":219,"mtime":1672321716243,"results":"44","hashOfConfig":"28"},{"size":351,"mtime":1672245291807,"results":"45","hashOfConfig":"28"},{"size":304,"mtime":1672282740615,"results":"46","hashOfConfig":"28"},{"size":383,"mtime":1672321593391,"results":"47","hashOfConfig":"28"},{"size":1766,"mtime":1672497484291,"results":"48","hashOfConfig":"28"},{"size":3474,"mtime":1672789045487,"results":"49","hashOfConfig":"28"},{"size":3129,"mtime":1672760964906,"results":"50","hashOfConfig":"28"},{"size":7104,"mtime":1672789113343,"results":"51","hashOfConfig":"28"},{"size":3050,"mtime":1672789060781,"results":"52","hashOfConfig":"28"},{"size":190,"mtime":1672788116762,"results":"53","hashOfConfig":"28"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},"10hd212",{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65","usedDeprecatedRules":"56"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"56"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"56"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"56"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"103","messages":"104","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"105","usedDeprecatedRules":"56"},{"filePath":"106","messages":"107","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"108","messages":"109","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"110","messages":"111","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},"/Users/abraham/Data-structures-editor/src/index.js",[],["112","113"],"/Users/abraham/Data-structures-editor/src/App.js",["114"],"/Users/abraham/Data-structures-editor/src/dataStructures/Graph.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Trie.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/Edge.js",["115","116"],"import React from \"react\"\nimport { NaturalCurve } from \"react-svg-curve\"\nimport { length, dif, sum, mul, divide, unit, perp, rotate, projectionOnCircle } from \"../algorithms/Geometry\";\n\nexport function Edge({ rank, from, to, weight, color, directed, dashedLine }) {\n  const radius = 25;\n\n  let bothEndpoints = (from !== undefined && to !== undefined);\n  let midPoint = { x: 0, y: 0 };\n  let fromOnCircle = { x: 0, y: 0 };\n  let toOnCircle = { x: 0, y: 0 };\n\n  if (bothEndpoints) {\n    let half = divide(sum(from, to), 2);\n    let dirHalfPerp = unit(perp(dif(from, half)))\n    midPoint = sum(half, mul(dirHalfPerp, -40 * rank));\n\n    fromOnCircle = projectionOnCircle(from, radius, midPoint);\n    toOnCircle = projectionOnCircle(to, radius, midPoint);\n  }\n\n  function getArrow() {\n    let dir = unit(dif(midPoint, toOnCircle));\n\n    // let p = sum(toOnCircle, mul(dir, radius));\n    let start = toOnCircle;\n    let end = sum(toOnCircle, mul(dir, 10));\n    let perpQ = unit(perp(dif(start, end)));\n    let perp1 = sum(end, mul(perpQ, 5));\n    let perp2 = sum(end, mul(perpQ, -5));\n\n    let str =\n      \" M \" + start.x + \",\" + start.y +\n      \" \" + perp1.x + \", \" + perp1.y +\n      \" \" + perp2.x + \" \" + perp2.y + \" z \";\n    // console.log(str);\n\n    return str;\n  }\n\n  const boldEdge = (color === \"black\" ? 1.5 : 3);\n  const dash = dashedLine ? 5 : 0;\n\n  return (\n    <g>\n      {\n        bothEndpoints &&\n        <NaturalCurve\n          data={[\n            [fromOnCircle.x, fromOnCircle.y],\n            [midPoint.x, midPoint.y],\n            [toOnCircle.x, toOnCircle.y],\n          ]}\n          stroke={color}\n          strokeWidth={boldEdge}\n          strokeDasharray={dash}\n          showPoints={false} />\n      }\n\n      {\n        (bothEndpoints && directed) &&\n        <path\n          d={getArrow()}\n          fill={color}\n          stroke={color} />\n      }\n\n      {\n        (bothEndpoints && weight) &&\n        <text\n          x={midPoint.x + 10}\n          y={midPoint.y + 10}\n          fill=\"black\" >\n          {weight}\n        </text>\n      }\n    </g>\n  );\n}\n\nexport function Loop({ from, to, weight, color, directed }) {\n  let bothEndpoints = (from !== undefined && to !== undefined);\n\n  let textPos = { x: 0, y: 0 };\n  if (bothEndpoints) {\n    textPos.x = (from.x + to.x) / 2;\n    textPos.y = (from.y + to.y) / 2;\n  }\n\n  const boldEdge = (color === \"black\" ? 1.5 : 3);\n  const dx = 0;\n  const dy = -35;\n\n  function getArrow() {\n    let loopOutside = {\n      x: from.x + 20,\n      y: from.y + dy\n    };\n\n    let dir = unit(dif(loopOutside, from));\n\n    let p = {\n      x: loopOutside.x - 5.5,\n      y: loopOutside.y + 13.5\n    };\n    let q = sum(p, mul(dir, 8));\n\n    let perpQ = unit(perp(dif(p, q)));\n    let perp1 = sum(q, mul(perpQ, 5));\n    let perp2 = sum(q, mul(perpQ, -5));\n\n    let str =\n      \" M \" + p.x + \",\" + p.y +\n      \" \" + perp1.x + \", \" + perp1.y +\n      \" \" + perp2.x + \" \" + perp2.y + \" z \";\n    // console.log(str);\n\n    return str;\n  }\n\n  console.log(from.x, from.y);\n\n  return (\n    <g>\n      {\n        bothEndpoints &&\n        <circle\n          cx={from.x + dx}\n          cy={from.y + dy}\n          r={20}\n          fill=\"none\"\n          stroke={color}\n          strokeWidth={boldEdge}\n        />\n      }\n\n      {\n        (bothEndpoints && directed) &&\n        <path\n          d={getArrow()}\n          fill={color}\n          stroke={color} />\n      }\n\n      {\n        (bothEndpoints && weight) &&\n        <text\n          x={textPos.x + dx}\n          y={textPos.y + 1.8 * dy}\n          fill=\"black\" >\n          {weight}\n        </text>\n      }\n    </g>\n  );\n}","/Users/abraham/Data-structures-editor/src/drawableComponents/Node.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/Rectangle.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Vector.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Matrix.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Stack.js",[],"/Users/abraham/Data-structures-editor/src/utils/Utils.js",["117"],"export const DEFAULT_NODE_COLOR = \"#c9a9ff\";\nexport const BLACK = \"black\";\n\nexport const BLOCK_HEIGHT = 50;\nexport const TEXT_SPACE = 20;\nexport const SPACE = 10;\nexport const BLOCK_WITH_VERTICAL_SPACE = BLOCK_HEIGHT + SPACE;\nexport const VERTICAL_DISTANCE = 80;\n\nexport function getRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function toNumber(number) {\n  return isNumeric(number) ? Number(number) : number;\n}\n\nexport function isNumeric(num) {\n  return !isNaN(num);\n}\n\nexport function isColor(x) {\n  x = x.toLowerCase();\n  let s = new Option().style\n  s.color = x\n  let test1 = s.color === x\n  let test2 = /^#[0-9A-F]{6}$/i.test(x)\n  return (test1 === true || test2 === true)\n}\n\nexport function isDash(x) {\n  x = x.toLowerCase();\n  return x === \"dash\";\n}\n\nexport function isSpace(c) {\n  return (c === ' ') || (c === '\\t');\n}\n\nexport function divideByTokens(str) {\n  let result = [];\n  let last = \"\";\n  for (let i in str) {\n    let c = str[i];\n    if (isSpace(c)) {\n      if (last !== \"\") {\n        result.push(last.trim());\n      }\n      last = \"\";\n    } else {\n      last += c;\n    }\n  }\n  if (last !== \"\") {\n    result.push(last.trim());\n  }\n  return result;\n}\n\nexport function isLight(color) {\n  let cur = color.charAt(0) === '#' ? color.substring(1, 7) : color;\n  let r = parseInt(cur.substring(0, 2), 16); // hexToR\n  let g = parseInt(cur.substring(2, 4), 16); // hexToG\n  let b = parseInt(cur.substring(4, 6), 16); // hexToB\n  return (((r * 0.299) + (g * 0.587) + (b * 0.114)) > 186);\n}\n\nexport function pickTextColor(color) {\n  return isLight(color) ? \"black\" : \"white\";\n}\n\nfunction getRGB(rgb) {\n  let el = document.createElement(\"div\");\n  el.style[\"background-color\"] = rgb;\n  document.body.appendChild(el);\n\n  let style = window.getComputedStyle(el);\n  let color = style[\"backgroundColor\"];\n  document.body.removeChild(el);\n\n  return color;\n}\n\nfunction parseColor(color) {\n  let arr = [];\n  color.replace(/[\\d+\\.]+/g, function (v) {\n    arr.push(parseFloat(v));\n  });\n  return \"#\" + arr.slice(0, 3).map(toHex).join(\"\");\n}\n\nfunction toHex(int) {\n  let hex = int.toString(16);\n  return hex.length === 1 ? \"0\" + hex : hex;\n}\n\nexport function lightenColor(col, amt) {\n  if (col.charAt(0) !== '#') {\n    col = parseColor(getRGB(col));\n  }\n\n  let cur = col.charAt(0) === '#' ? col.substring(1, 7) : col;\n\n  let r = Math.max(Math.min(255, parseInt(cur.substring(0, 2), 16) + amt), 0).toString(16)\n  let g = Math.max(Math.min(255, parseInt(cur.substring(2, 4), 16) + amt), 0).toString(16)\n  let b = Math.max(Math.min(255, parseInt(cur.substring(4, 6), 16) + amt), 0).toString(16)\n\n  const rr = (r.length < 2 ? '0' : '') + r\n  const gg = (g.length < 2 ? '0' : '') + g\n  const bb = (b.length < 2 ? '0' : '') + b\n  return `#${rr}${gg}${bb}`\n}\n\nexport function getWidthFromText(text) {\n  return Math.max(BLOCK_HEIGHT, text.length * 12);\n}\n\nexport function isSmaller(a, b) {\n  if (isNumeric(a) && isNumeric(b)) {\n    return a - b;\n  }\n  return a < b ? -1 : +1;\n}","/Users/abraham/Data-structures-editor/src/algorithms/Geometry.js",[],"/Users/abraham/Data-structures-editor/src/components/Canvas.js",["118","119","120","121","122","123"],"import React, { useState, useCallback, useThrottled, useEffect } from \"react\";\nimport Rectangle from \"../drawableComponents/Rectangle\";\n\nconst MAX_ZOOM = 4;\nconst MIN_ZOOM = 0.3;\nconst ZOOM_INCREMENT = 0.25;\n\nexport default function Canvas({ objects }) {\n  const [zoom, setZoom] = useState(1.5);\n  const [dragging, setDragging] = useState(false);\n  const [top, setTop] = useState(0);\n  const [left, setLeft] = useState(50);\n  const [relativeTop, setRelativeTop] = useState(0);\n  const [relativeLeft, setRelativeLeft] = useState(0);\n  const [windowWidth, setWindowWidth] = useState(Number(window.innerWidth));\n  const [windowHeight, setWindowHeight] = useState(Number(window.innerHeight));\n\n  const zoomInOutMouseWheel = useCallback((e) => {\n    const newzoom = zoom - e.deltaY * 0.001;\n    setZoom(Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newzoom)));\n  }, [zoom]);\n\n  const mouseDown = useCallback((e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    if (e.button !== 0) {\n      return; // Should only run code from left mouse click\n    }\n    // console.log(\"mouseDown\", e.pageX, e.pageY, e);\n    setDragging(true);\n    setRelativeLeft(e.pageX - left);\n    setRelativeTop(e.pageY - top);\n  }, [left, top]);\n\n  const mouseUp = useCallback((e) => {\n    // console.log(\"mouseUp\");\n    e.stopPropagation();\n    e.preventDefault();\n    setDragging(false);\n  }, []);\n\n  const moveMouse = useCallback((e) => {\n    // console.log(\"moveMouse\");\n    e.stopPropagation();\n    e.preventDefault();\n    if (!dragging) {\n      return;\n    }\n    setLeft(e.pageX - relativeLeft);\n    setTop(e.pageY - relativeTop);\n  }, [dragging]);\n\n  useEffect(() => {\n    // console.log(left, top, dragging);\n\n    document.addEventListener('mousemove', moveMouse);\n    document.addEventListener('mouseup', mouseUp);\n    // window.addEventListener('resize', updateWindowDimensions);\n    return () => {\n      document.removeEventListener('mousemove', moveMouse);\n      document.removeEventListener('mouseup', mouseUp);\n      // window.removeEventListener('resize', updateWindowDimensions);\n    };\n  }, [moveMouse, mouseUp, mouseDown]);\n\n  return (\n    <div className=\"scrollable-image\">\n      <svg className=\"image\"\n        viewBox={`${-left} ${-top} ${windowWidth} ${windowHeight}`}\n        onWheel={zoomInOutMouseWheel}\n        onMouseDown={mouseDown}\n        onMouseUp={mouseUp}\n        onMouseMove={moveMouse}>\n        <g transform={`scale(${zoom})`}>\n          {objects}\n        </g>\n      </svg>\n    </div>\n  );\n}","/Users/abraham/Data-structures-editor/src/utils/TextParser.js",["124","125"],"import { isColor, divideByTokens, isSmaller } from \"./Utils\";\nimport { VERTICAL_DISTANCE, BLOCK_HEIGHT } from \"./Utils\"\n\nimport { Graph } from \"../dataStructures/Graph\";\nimport { Trie } from \"../dataStructures/Trie\";\nimport { Sides, Vector } from \"../dataStructures/Vector\";\nimport { Matrix } from \"../dataStructures/Matrix\";\nimport { Stack } from \"../dataStructures/Stack\";\nimport { Queue } from \"../dataStructures/Queue\";\nimport { Deque } from \"../dataStructures/Deque\";\nimport { Heap, HeapType } from \"../dataStructures/Heap\";\nimport { STLSet } from \"../dataStructures/STLSet\";\nimport { STLMap } from \"../dataStructures/STLMap\";\n\nimport { Indices } from \"../dataStructures/Indices\";\nimport { STLIndices } from \"../dataStructures/STLIndices\";\n\nimport { DataStructuresIdentifier } from \"./DataStructuresIdentifier\";\nimport { CppIdentifier } from \"./CppIdentifier\";\nimport { LastAction } from \"../dataStructures/STLMap\";\n\nexport class TextParser {\n  constructor(text, oldParser = null) {\n    const lines = text.split('\\n').filter((line) => {\n      return line.length > 0;\n    });\n\n    this.textObjects = this.splitInTextObjects(lines);\n\n    this.objects = [];\n    this.lastTop = 0;\n    let objectCount = new Map();\n    this.textObjects.forEach((element, index) => {\n      let object = this.getObject(element, null);\n      this.lastTop += object.height;\n      this.lastTop += VERTICAL_DISTANCE;\n\n      if (element.name) {\n        object.name = element.name;\n      } else {\n        const id = (objectCount.get(object.name) ?? 0) + 1;\n        objectCount.set(object.name, id);\n        object.name += \" \" + id;\n      }\n\n      this.objects.push(object);\n\n      // add indices if is a vector, array or matrix\n      if (DataStructuresIdentifier.isVector(element.type) ||\n        DataStructuresIdentifier.isMatrix(element.type)) {\n        this.objects.push(new Indices(element.type, object));\n      }\n\n      // add top, bottom, front, back, begin, end if it is a stack, queue, deque, heap, set, map\n      if (DataStructuresIdentifier.isStack(element.type) ||\n        DataStructuresIdentifier.isQueue(element.type) ||\n        DataStructuresIdentifier.isDeque(element.type) ||\n        DataStructuresIdentifier.isHeap(element.type) ||\n        DataStructuresIdentifier.isSet(element.type) ||\n        DataStructuresIdentifier.isMap(element.type)) {\n        this.objects.push(new STLIndices(element.type, object));\n      }\n    });\n  }\n\n  getObject(element, previousObject = null) {\n    if (DataStructuresIdentifier.isVector(element.type)) {\n      return this.getVector(element.lines);\n    } else if (DataStructuresIdentifier.isMatrix(element.type)) {\n      return this.getMatrix(element.lines);\n    } else if (DataStructuresIdentifier.isStack(element.type)) {\n      return this.getStack(element.lines);\n    } else if (DataStructuresIdentifier.isQueue(element.type)) {\n      return this.getQueue(element.lines);\n    } else if (DataStructuresIdentifier.isDeque(element.type)) {\n      return this.getDeque(element.lines);\n    } else if (DataStructuresIdentifier.isHeap(element.type)) {\n      return this.getHeap(element.lines);\n    } else if (DataStructuresIdentifier.isSet(element.type)) {\n      return this.getSet(element.lines);\n    } if (DataStructuresIdentifier.isMap(element.type)) {\n      return this.getMap(element.lines);\n    } if (DataStructuresIdentifier.isGraph(element.type)) {\n      return this.getGraph(element.lines, null);\n    } else if (DataStructuresIdentifier.isTrie(element.type)) {\n      return this.getTrie(element.lines);\n    }\n    return null;\n  }\n\n  getNameIfAny(line) {\n    let tokens = divideByTokens(line);\n    tokens.shift();\n    return tokens.join(\" \");\n  }\n\n  splitInTextObjects(lines) {\n    // Objets are in the form [{ object type, lines of text }]\n    let objects = [];\n    let start = -1;\n    for (let pos = 0; pos <= lines.length; pos++) {\n      if (pos === lines.length || DataStructuresIdentifier.isObject(lines[pos])) {\n        if (start !== -1) {\n          objects.push({\n            type: divideByTokens(lines[start].toLowerCase()).shift(),\n            name: this.getNameIfAny(lines[start]),\n            lines: lines.slice(start + 1, pos).map((line) => {\n              return divideByTokens(line);\n            }),\n          });\n        }\n        start = pos;\n      }\n    }\n    return objects;\n  }\n\n  getVector(lines) {\n    const vector = new Vector(this.lastTop);\n\n    let sortArray = false;\n    let reverseArray = false;\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        vector.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (element === \"sort\") {\n          sortArray = true;\n        } else if (element === \"reverse\") {\n          reverseArray = !reverseArray;\n        } else if (isColor(element)) {\n          // update color of the last element if any\n          vector.updateLastElementColor(element);\n        } else if (CppIdentifier.isPushBack(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPopBack(element)) {\n          vector.popBack();\n        } else {\n          vector.pushBack(element);\n        }\n      }\n    }\n\n    if (sortArray) {\n      vector.data.sort((a, b) => isSmaller(a.value, b.value));\n    }\n\n    if (reverseArray) {\n      vector.data.reverse();\n    }\n\n    return vector;\n  }\n\n  getMatrix(lines) {\n    const matrix = new Matrix(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        matrix.currentColor = line[0];\n        continue;\n      }\n\n      let newRowAdded = false;\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          matrix.updateLastElementColor(element);\n        } else {\n          if (!newRowAdded) {\n            matrix.addRow();\n            newRowAdded = true;\n          }\n          matrix.lastRowPushBack(element);\n        }\n      }\n    }\n\n    if (matrix.empty()) {\n      matrix.height = BLOCK_HEIGHT;\n    }\n\n    return matrix;\n  }\n\n  getQueue(lines) {\n    const queue = new Queue(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        queue.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          queue.updateLastElementColor(element);\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPop(element)) {\n          queue.pop();\n        } else {\n          queue.push(element);\n        }\n      }\n    }\n\n    return queue;\n  }\n\n  getStack(lines) {\n    const stack = new Stack(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        stack.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          stack.updateLastElementColor(element);\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPop(element)) {\n          stack.pop();\n        } else {\n          stack.push(element);\n        }\n      }\n    }\n\n    stack.updateHeight();\n\n    return stack;\n  }\n\n  getDeque(lines) {\n    const deque = new Deque(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        deque.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          deque.updateLastElementColor(element);\n        } else if (CppIdentifier.isPushBack(element)) {\n          deque.side = Sides.BACK;\n        } else if (CppIdentifier.isPushFront(element)) {\n          deque.side = Sides.FRONT;\n        } else if (CppIdentifier.isPopBack(element)) {\n          deque.popBack();\n        } else if (CppIdentifier.isPopFront(element)) {\n          deque.popFront();\n        } else {\n          deque.push(element);\n        }\n      }\n    }\n\n    return deque;\n  }\n\n  getHeap(lines) {\n    const heap = new Heap(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        heap.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          heap.updateLastElementColor(element);\n        } else if (CppIdentifier.isPop(element)) {\n          heap.pop();\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isMax(element)) {\n          heap.heapType = HeapType.MAX;\n        } else if (CppIdentifier.isMin(element)) {\n          heap.heapType = HeapType.MIN;\n        } else {\n          heap.push(element);\n        }\n      }\n    }\n\n    heap.updateHeight();\n\n    return heap;\n  }\n\n  getSet(lines) {\n    const set = new STLSet(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        set.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          set.updateLastElementColor(element);\n        } else if (CppIdentifier.isErase(element)) {\n          set.lastAction = LastAction.ERASE;\n        } else if (CppIdentifier.isInsert(element)) {\n          set.lastAction = LastAction.INSERT;\n        } else {\n          if (set.lastAction === LastAction.INSERT) {\n            set.insert(element);\n          } else {\n            set.erase(element);\n          }\n          // reset to set insert as default\n          set.lastAction = LastAction.INSERT;\n        }\n      }\n    }\n\n    set.updateHeight();\n\n    return set;\n  }\n\n  getMap(lines) {\n    const map = new STLMap(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        map.currentColor = line[0];\n        continue;\n      }\n\n      let key = null;\n      let value = null;\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          map.updateLastElementColor(element);\n        } else if (CppIdentifier.isErase(element)) {\n          map.lastAction = LastAction.ERASE;\n        } else if (CppIdentifier.isInsert(element)) {\n          map.lastAction = LastAction.INSERT;\n        } else {\n          if (map.lastAction === LastAction.INSERT) {\n            if (key === null) {\n              key = element;\n            } else if (key !== null) {\n              value = element;\n              map.insert(key, value);\n              key = null;\n              value = null;\n            }\n          } else {\n            map.erase(element);\n            key = null;\n            value = null;\n          }\n          // reset to set insert as default\n          map.lastAction = LastAction.INSERT;\n        }\n      }\n    }\n\n    map.updateHeight();\n\n    return map;\n  }\n\n  // getGraph(lines, previousGraph) {\n  //   const graph = new Graph(false, previousGraph);\n\n  //   for (const line of lines) {\n  //     if (line.length === 1) {\n  //       const x = line[0];\n  //       if (isColor(x)) {\n  //         // paint everything that's below with this color\n  //         graph.currentNodeColor = x;\n  //       } else {\n  //         // Single node\n  //         const u = line[0];\n  //         graph.addNode(u, {});\n  //       }\n  //     } else if (line.length === 2) {\n  //       const u = line[0];\n  //       const x = line[1];\n  //       if (isColor(x)) {\n  //         // Node with color x\n  //         graph.addNode(u, { color: x });\n  //       } else {\n  //         // Edge u -> v (depends on the flag)\n  //         const v = line[1];\n  //         graph.addEdge(u, v, \"\");\n  //       }\n  //     } else if (line.length >= 3) {\n  //       const u = line[0];\n  //       const v = line[1];\n\n  //       // Edge u -> v with color | weight | dash\n  //       let weight = \"\";\n  //       let color = \"black\";\n  //       let dashedLine = false;\n  //       for (let i = 2; i < line.length; i++) {\n  //         const x = line[i];\n  //         if (isColor(x)) {\n  //           color = x;\n  //         } else if (isDash(x)) {\n  //           dashedLine = true;\n  //         } else {\n  //           weight += x + \" \";\n  //         }\n  //       }\n\n  //       graph.addEdge(u, v, weight, color, dashedLine);\n  //     }\n  //   }\n\n  //   return graph;\n  // }\n\n  // getTrie(lines) {\n  //   const trie = new Trie(addNode, addEdge);\n  //   currentNodeColor = \"red\";\n  //   for (const line of lines) {\n  //     if (object.length === 1) {\n  //       if (isColor(object[0])) {\n  //         // change the color of all below nodes\n  //         currentNodeColor = object[0];\n  //       } else {\n  //         // insert a word with the currentNodeColor\n  //         const word = object[0];\n  //         trie.insert(word, currentNodeColor);\n  //       }\n  //     } else if (object.length === 2) {\n  //       // insert a word with possibly a custom color\n  //       const word = object[0];\n  //       let color = currentNodeColor;\n  //       if (object.length === 2 && isColor(object[1])) {\n  //         color = object[1];\n  //       }\n  //       trie.insert(word, color);\n  //     }\n  //   }\n  //   trie.dfs(trie.root, \"*\");\n  // }\n}","/Users/abraham/Data-structures-editor/src/utils/DataStructuresIdentifier.js",[],"/Users/abraham/Data-structures-editor/src/utils/CppIdentifier.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Queue.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/EmptyDataStructure.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Deque.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/Text.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Indices.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/STLIndices.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Heap.js",["126"],"import { isSmaller, DEFAULT_NODE_COLOR, SPACE, BLOCK_HEIGHT, BLOCK_WITH_VERTICAL_SPACE } from \"../utils/Utils\";\nimport { Graph } from \"./Graph\";\nimport { distanceY } from \"../algorithms/Buchheim\";\nimport EmptyDataStructure from \"../drawableComponents/EmptyDataStructure\";\n\nexport const HeapType = {\n  MIN: -1,\n  MAX: 1,\n};\n\nexport class Heap {\n  constructor(top, name = \"Priority Queue\") {\n    this.name = name;\n    this.currentColor = DEFAULT_NODE_COLOR;\n    this.data = [null];\n\n    this.left = 0;\n    this.top = top;\n    this.height = 0;\n    this.width = 0;\n\n    this.heapType = HeapType.MAX;\n\n    this.lastIndex = 0;\n  }\n\n  updateLastElementColor(color) {\n    // TODO: save the position of the node :p\n    console.log(this.lastIndex);\n    if (this.lastIndex !== 0 && this.data.length) {\n      this.data.at(this.lastIndex).color = color;\n    }\n  }\n\n  updateHeight() {\n    if (this.data.length <= 2) {\n      this.height = BLOCK_HEIGHT;\n    } else {\n      let treeHeight = Math.floor(Math.log2(this.data.length - 1));\n      this.height = treeHeight * distanceY + BLOCK_HEIGHT;\n    }\n  }\n\n  push(value, color = null) {\n    this.data.push({\n      value: value,\n      color: color ?? this.currentColor,\n    });\n    this.lastIndex = this.data.length - 1;\n    this.bubbleUp(this.data.length - 1);\n    this.updateHeight();\n  }\n\n  pop() {\n    this.swap(1, this.data.length - 1);\n    this.data.pop();\n    this.bubbleDown(1);\n    this.updateHeight();\n  }\n\n  topNode() {\n    return this.graph.nodes.get(1);\n  }\n\n  swap(i, j) {\n    let tmp = this.data[i];\n    this.data[i] = this.data[j];\n    this.data[j] = tmp;\n  }\n\n  compare(i, j) {\n    let small = isSmaller(this.data[i].value, this.data[j].value) < 0;\n    return this.heapType === HeapType.MIN ? small : !small;\n  }\n\n  bubbleUp(index) {\n    let parent = Math.floor(index / 2);\n    if (parent === 0) {\n      return;\n    }\n    if (this.compare(index, parent)) {\n      this.lastIndex = parent;\n      this.swap(index, parent);\n      this.bubbleUp(parent);\n    }\n  }\n\n  bubbleDown(index) {\n    let left = index * 2;\n    let right = index * 2 + 1;\n\n    let largest = index;\n    if (left < this.data.length && this.compare(left, largest))\n      largest = left;\n\n    if (right < this.data.length && this.compare(right, largest))\n      largest = right;\n\n    if (largest !== index) {\n      this.lastIndex = largest;\n      this.swap(largest, index);\n      this.bubbleDown(largest);\n    }\n  }\n\n  empty() {\n    return this.data.length - 1 === 0;\n  }\n\n  get draw() {\n    if (this.empty()) {\n      return (\n        <EmptyDataStructure\n          x={this.left}\n          y={this.top}\n        />\n      );\n    }\n\n    this.graph = new Graph(this.top + 3.5 * SPACE, /* directed */ false);\n    for (let index = 1; index < this.data.length; index++) {\n      this.graph.addNode(index, this.data[index].color, this.data[index].value);\n\n      if (index * 2 < this.data.length) {\n        this.graph.addEdge(index, index * 2);\n      }\n      if (index * 2 + 1 < this.data.length) {\n        this.graph.addEdge(index, index * 2 + 1);\n      }\n    }\n\n    this.graph.arrangeAsTree();\n\n    return this.graph.draw;\n  }\n}","/Users/abraham/Data-structures-editor/src/algorithms/Buchheim.js",["127","128","129","130","131"],"/Users/abraham/Data-structures-editor/src/dataStructures/STLMap.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/STLSet.js",[],{"ruleId":"132","replacedBy":"133"},{"ruleId":"134","replacedBy":"135"},{"ruleId":"136","severity":1,"message":"137","line":141,"column":6,"nodeType":"138","endLine":141,"endColumn":12,"suggestions":"139"},{"ruleId":"140","severity":1,"message":"141","line":3,"column":10,"nodeType":"142","messageId":"143","endLine":3,"endColumn":16},{"ruleId":"140","severity":1,"message":"144","line":3,"column":53,"nodeType":"142","messageId":"143","endLine":3,"endColumn":59},{"ruleId":"145","severity":1,"message":"146","line":86,"column":22,"nodeType":"147","messageId":"148","endLine":86,"endColumn":23,"suggestions":"149"},{"ruleId":"140","severity":1,"message":"150","line":1,"column":40,"nodeType":"142","messageId":"143","endLine":1,"endColumn":52},{"ruleId":"140","severity":1,"message":"151","line":2,"column":8,"nodeType":"142","messageId":"143","endLine":2,"endColumn":17},{"ruleId":"140","severity":1,"message":"152","line":6,"column":7,"nodeType":"142","messageId":"143","endLine":6,"endColumn":21},{"ruleId":"140","severity":1,"message":"153","line":15,"column":23,"nodeType":"142","messageId":"143","endLine":15,"endColumn":37},{"ruleId":"140","severity":1,"message":"154","line":16,"column":24,"nodeType":"142","messageId":"143","endLine":16,"endColumn":39},{"ruleId":"136","severity":1,"message":"155","line":51,"column":6,"nodeType":"138","endLine":51,"endColumn":16,"suggestions":"156"},{"ruleId":"140","severity":1,"message":"157","line":4,"column":10,"nodeType":"142","messageId":"143","endLine":4,"endColumn":15},{"ruleId":"140","severity":1,"message":"158","line":5,"column":10,"nodeType":"142","messageId":"143","endLine":5,"endColumn":14},{"ruleId":"140","severity":1,"message":"159","line":1,"column":62,"nodeType":"142","messageId":"143","endLine":1,"endColumn":87},{"ruleId":"140","severity":1,"message":"160","line":207,"column":9,"nodeType":"142","messageId":"143","endLine":207,"endColumn":16},{"ruleId":"140","severity":1,"message":"161","line":229,"column":19,"nodeType":"142","messageId":"143","endLine":229,"endColumn":25},{"ruleId":"140","severity":1,"message":"162","line":237,"column":13,"nodeType":"142","messageId":"143","endLine":237,"endColumn":17},{"ruleId":"140","severity":1,"message":"162","line":243,"column":13,"nodeType":"142","messageId":"143","endLine":243,"endColumn":17},{"ruleId":"140","severity":1,"message":"162","line":250,"column":13,"nodeType":"142","messageId":"143","endLine":250,"endColumn":17},"no-native-reassign",["163"],"no-negated-in-lhs",["164"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'parser'. Either include it or remove the dependency array.","ArrayExpression",["165"],"no-unused-vars","'length' is defined but never used.","Identifier","unusedVar","'rotate' is defined but never used.","no-useless-escape","Unnecessary escape character: \\..","Literal","unnecessaryEscape",["166","167"],"'useThrottled' is defined but never used.","'Rectangle' is defined but never used.","'ZOOM_INCREMENT' is assigned a value but never used.","'setWindowWidth' is assigned a value but never used.","'setWindowHeight' is assigned a value but never used.","React Hook useCallback has missing dependencies: 'relativeLeft' and 'relativeTop'. Either include them or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setLeft' needs the current value of 'relativeLeft'.",["168"],"'Graph' is defined but never used.","'Trie' is defined but never used.","'BLOCK_WITH_VERTICAL_SPACE' is defined but never used.","'byLabel' is assigned a value but never used.","'values' is assigned a value but never used.","'node' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"169","fix":"170"},{"messageId":"171","fix":"172","desc":"173"},{"messageId":"174","fix":"175","desc":"176"},{"desc":"177","fix":"178"},"Update the dependencies array to be: [parser, text]",{"range":"179","text":"180"},"removeEscape",{"range":"181","text":"182"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"183","text":"184"},"Replace the `\\` with `\\\\` to include the actual backslash character.","Update the dependencies array to be: [dragging, relativeLeft, relativeTop]",{"range":"185","text":"186"},[2979,2985],"[parser, text]",[1950,1951],"",[1950,1950],"\\",[1609,1619],"[dragging, relativeLeft, relativeTop]"]