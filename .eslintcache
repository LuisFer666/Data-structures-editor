[{"/Users/abraham/Data-structures-editor/src/index.js":"1","/Users/abraham/Data-structures-editor/src/App.js":"2","/Users/abraham/Data-structures-editor/src/dataStructures/Graph.js":"3","/Users/abraham/Data-structures-editor/src/dataStructures/Trie.js":"4","/Users/abraham/Data-structures-editor/src/drawableComponents/Edge.js":"5","/Users/abraham/Data-structures-editor/src/drawableComponents/Node.js":"6","/Users/abraham/Data-structures-editor/src/drawableComponents/Rectangle.js":"7","/Users/abraham/Data-structures-editor/src/dataStructures/Vector.js":"8","/Users/abraham/Data-structures-editor/src/dataStructures/Matrix.js":"9","/Users/abraham/Data-structures-editor/src/dataStructures/Stack.js":"10","/Users/abraham/Data-structures-editor/src/utils/Utils.js":"11","/Users/abraham/Data-structures-editor/src/algorithms/Geometry.js":"12","/Users/abraham/Data-structures-editor/src/components/Canvas.js":"13","/Users/abraham/Data-structures-editor/src/utils/TextParser.js":"14","/Users/abraham/Data-structures-editor/src/utils/DataStructuresIdentifier.js":"15","/Users/abraham/Data-structures-editor/src/utils/CppIdentifier.js":"16","/Users/abraham/Data-structures-editor/src/dataStructures/Queue.js":"17","/Users/abraham/Data-structures-editor/src/drawableComponents/EmptyDataStructure.js":"18","/Users/abraham/Data-structures-editor/src/dataStructures/Deque.js":"19","/Users/abraham/Data-structures-editor/src/drawableComponents/Text.js":"20","/Users/abraham/Data-structures-editor/src/dataStructures/Indices.js":"21","/Users/abraham/Data-structures-editor/src/dataStructures/STLIndices.js":"22","/Users/abraham/Data-structures-editor/src/dataStructures/Heap.js":"23","/Users/abraham/Data-structures-editor/src/algorithms/Buchheim.js":"24"},{"size":152,"mtime":1671550730802,"results":"25","hashOfConfig":"26"},{"size":3595,"mtime":1672511217864,"results":"27","hashOfConfig":"26"},{"size":3679,"mtime":1672496316661,"results":"28","hashOfConfig":"26"},{"size":882,"mtime":1672237391934,"results":"29","hashOfConfig":"26"},{"size":3588,"mtime":1672237458260,"results":"30","hashOfConfig":"26"},{"size":2306,"mtime":1672510359863,"results":"31","hashOfConfig":"26"},{"size":727,"mtime":1672245405362,"results":"32","hashOfConfig":"26"},{"size":2006,"mtime":1672320335671,"results":"33","hashOfConfig":"26"},{"size":1474,"mtime":1672497484291,"results":"34","hashOfConfig":"26"},{"size":1026,"mtime":1672497484296,"results":"35","hashOfConfig":"26"},{"size":2896,"mtime":1672504890989,"results":"36","hashOfConfig":"26"},{"size":938,"mtime":1671550730800,"results":"37","hashOfConfig":"26"},{"size":2492,"mtime":1672322055363,"results":"38","hashOfConfig":"26"},{"size":10921,"mtime":1672510124200,"results":"39","hashOfConfig":"26"},{"size":965,"mtime":1672325487805,"results":"40","hashOfConfig":"26"},{"size":570,"mtime":1672325225169,"results":"41","hashOfConfig":"26"},{"size":219,"mtime":1672321716243,"results":"42","hashOfConfig":"26"},{"size":351,"mtime":1672245291807,"results":"43","hashOfConfig":"26"},{"size":304,"mtime":1672282740615,"results":"44","hashOfConfig":"26"},{"size":383,"mtime":1672321593391,"results":"45","hashOfConfig":"26"},{"size":1766,"mtime":1672497484291,"results":"46","hashOfConfig":"26"},{"size":2351,"mtime":1672510329781,"results":"47","hashOfConfig":"26"},{"size":3129,"mtime":1672511129689,"results":"48","hashOfConfig":"26"},{"size":7103,"mtime":1672495853589,"results":"49","hashOfConfig":"26"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},"10hd212",{"filePath":"53","messages":"54","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"52"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"52"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"52"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82","usedDeprecatedRules":"52"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"101","messages":"102","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"103","usedDeprecatedRules":"52"},"/Users/abraham/Data-structures-editor/src/index.js",[],["104","105"],"/Users/abraham/Data-structures-editor/src/App.js",["106"],"/Users/abraham/Data-structures-editor/src/dataStructures/Graph.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Trie.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/Edge.js",["107","108"],"import React from \"react\"\nimport { NaturalCurve } from \"react-svg-curve\"\nimport { length, dif, sum, mul, divide, unit, perp, rotate, projectionOnCircle } from \"../algorithms/Geometry\";\n\nexport function Edge({ rank, from, to, weight, color, directed, dashedLine }) {\n  const radius = 25;\n\n  let bothEndpoints = (from !== undefined && to !== undefined);\n  let midPoint = { x: 0, y: 0 };\n  let fromOnCircle = { x: 0, y: 0 };\n  let toOnCircle = { x: 0, y: 0 };\n\n  if (bothEndpoints) {\n    let half = divide(sum(from, to), 2);\n    let dirHalfPerp = unit(perp(dif(from, half)))\n    midPoint = sum(half, mul(dirHalfPerp, -40 * rank));\n\n    fromOnCircle = projectionOnCircle(from, radius, midPoint);\n    toOnCircle = projectionOnCircle(to, radius, midPoint);\n  }\n\n  function getArrow() {\n    let dir = unit(dif(midPoint, toOnCircle));\n\n    // let p = sum(toOnCircle, mul(dir, radius));\n    let start = toOnCircle;\n    let end = sum(toOnCircle, mul(dir, 10));\n    let perpQ = unit(perp(dif(start, end)));\n    let perp1 = sum(end, mul(perpQ, 5));\n    let perp2 = sum(end, mul(perpQ, -5));\n\n    let str =\n      \" M \" + start.x + \",\" + start.y +\n      \" \" + perp1.x + \", \" + perp1.y +\n      \" \" + perp2.x + \" \" + perp2.y + \" z \";\n    // console.log(str);\n\n    return str;\n  }\n\n  const boldEdge = (color === \"black\" ? 1.5 : 3);\n  const dash = dashedLine ? 5 : 0;\n\n  return (\n    <g>\n      {\n        bothEndpoints &&\n        <NaturalCurve\n          data={[\n            [fromOnCircle.x, fromOnCircle.y],\n            [midPoint.x, midPoint.y],\n            [toOnCircle.x, toOnCircle.y],\n          ]}\n          stroke={color}\n          strokeWidth={boldEdge}\n          strokeDasharray={dash}\n          showPoints={false} />\n      }\n\n      {\n        (bothEndpoints && directed) &&\n        <path\n          d={getArrow()}\n          fill={color}\n          stroke={color} />\n      }\n\n      {\n        (bothEndpoints && weight) &&\n        <text\n          x={midPoint.x + 10}\n          y={midPoint.y + 10}\n          fill=\"black\" >\n          {weight}\n        </text>\n      }\n    </g>\n  );\n}\n\nexport function Loop({ from, to, weight, color, directed }) {\n  let bothEndpoints = (from !== undefined && to !== undefined);\n\n  let textPos = { x: 0, y: 0 };\n  if (bothEndpoints) {\n    textPos.x = (from.x + to.x) / 2;\n    textPos.y = (from.y + to.y) / 2;\n  }\n\n  const boldEdge = (color === \"black\" ? 1.5 : 3);\n  const dx = 0;\n  const dy = -35;\n\n  function getArrow() {\n    let loopOutside = {\n      x: from.x + 20,\n      y: from.y + dy\n    };\n\n    let dir = unit(dif(loopOutside, from));\n\n    let p = {\n      x: loopOutside.x - 5.5,\n      y: loopOutside.y + 13.5\n    };\n    let q = sum(p, mul(dir, 8));\n\n    let perpQ = unit(perp(dif(p, q)));\n    let perp1 = sum(q, mul(perpQ, 5));\n    let perp2 = sum(q, mul(perpQ, -5));\n\n    let str =\n      \" M \" + p.x + \",\" + p.y +\n      \" \" + perp1.x + \", \" + perp1.y +\n      \" \" + perp2.x + \" \" + perp2.y + \" z \";\n    // console.log(str);\n\n    return str;\n  }\n\n  console.log(from.x, from.y);\n\n  return (\n    <g>\n      {\n        bothEndpoints &&\n        <circle\n          cx={from.x + dx}\n          cy={from.y + dy}\n          r={20}\n          fill=\"none\"\n          stroke={color}\n          strokeWidth={boldEdge}\n        />\n      }\n\n      {\n        (bothEndpoints && directed) &&\n        <path\n          d={getArrow()}\n          fill={color}\n          stroke={color} />\n      }\n\n      {\n        (bothEndpoints && weight) &&\n        <text\n          x={textPos.x + dx}\n          y={textPos.y + 1.8 * dy}\n          fill=\"black\" >\n          {weight}\n        </text>\n      }\n    </g>\n  );\n}","/Users/abraham/Data-structures-editor/src/drawableComponents/Node.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/Rectangle.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Vector.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Matrix.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Stack.js",[],"/Users/abraham/Data-structures-editor/src/utils/Utils.js",["109"],"export const DEFAULT_NODE_COLOR = \"#c9a9ff\";\nexport const BLACK = \"black\";\n\nexport const BLOCK_HEIGHT = 50;\nexport const TEXT_SPACE = 20;\nexport const SPACE = 10;\nexport const BLOCK_WITH_VERTICAL_SPACE = BLOCK_HEIGHT + SPACE;\nexport const VERTICAL_DISTANCE = 80;\n\nexport function getRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function isNumeric(num) {\n  return !isNaN(num)\n}\n\nexport function isColor(x) {\n  x = x.toLowerCase();\n  let s = new Option().style\n  s.color = x\n  let test1 = s.color === x\n  let test2 = /^#[0-9A-F]{6}$/i.test(x)\n  return (test1 === true || test2 === true)\n}\n\nexport function isDash(x) {\n  x = x.toLowerCase();\n  return x === \"dash\";\n}\n\nexport function isSpace(c) {\n  return (c === ' ') || (c === '\\t');\n}\n\nexport function divideByTokens(str) {\n  let result = [];\n  let last = \"\";\n  for (let i in str) {\n    let c = str[i];\n    if (isSpace(c)) {\n      if (last !== \"\") {\n        result.push(last.trim());\n      }\n      last = \"\";\n    } else {\n      last += c;\n    }\n  }\n  if (last !== \"\") {\n    result.push(last.trim());\n  }\n  return result;\n}\n\nexport function isLight(color) {\n  let cur = color.charAt(0) === '#' ? color.substring(1, 7) : color;\n  let r = parseInt(cur.substring(0, 2), 16); // hexToR\n  let g = parseInt(cur.substring(2, 4), 16); // hexToG\n  let b = parseInt(cur.substring(4, 6), 16); // hexToB\n  return (((r * 0.299) + (g * 0.587) + (b * 0.114)) > 186);\n}\n\nexport function pickTextColor(color) {\n  return isLight(color) ? \"black\" : \"white\";\n}\n\nfunction getRGB(rgb) {\n  let el = document.createElement(\"div\");\n  el.style[\"background-color\"] = rgb;\n  document.body.appendChild(el);\n\n  let style = window.getComputedStyle(el);\n  let color = style[\"backgroundColor\"];\n  document.body.removeChild(el);\n\n  return color;\n}\n\nfunction parseColor(color) {\n  let arr = [];\n  color.replace(/[\\d+\\.]+/g, function (v) {\n    arr.push(parseFloat(v));\n  });\n  return \"#\" + arr.slice(0, 3).map(toHex).join(\"\");\n}\n\nfunction toHex(int) {\n  let hex = int.toString(16);\n  return hex.length === 1 ? \"0\" + hex : hex;\n}\n\nexport function lightenColor(col, amt) {\n  if (col.charAt(0) !== '#') {\n    col = parseColor(getRGB(col));\n  }\n\n  let cur = col.charAt(0) === '#' ? col.substring(1, 7) : col;\n\n  let r = Math.max(Math.min(255, parseInt(cur.substring(0, 2), 16) + amt), 0).toString(16)\n  let g = Math.max(Math.min(255, parseInt(cur.substring(2, 4), 16) + amt), 0).toString(16)\n  let b = Math.max(Math.min(255, parseInt(cur.substring(4, 6), 16) + amt), 0).toString(16)\n\n  const rr = (r.length < 2 ? '0' : '') + r\n  const gg = (g.length < 2 ? '0' : '') + g\n  const bb = (b.length < 2 ? '0' : '') + b\n  return `#${rr}${gg}${bb}`\n}\n\nexport function getWidthFromText(text) {\n  return Math.max(BLOCK_HEIGHT, text.length * 12);\n}\n\nexport function isSmaller(a, b) {\n  if (isNumeric(a) && isNumeric(b)) {\n    return a - b;\n  }\n  return a < b ? -1 : +1;\n}","/Users/abraham/Data-structures-editor/src/algorithms/Geometry.js",[],"/Users/abraham/Data-structures-editor/src/components/Canvas.js",["110","111","112","113","114","115"],"import React, { useState, useCallback, useThrottled, useEffect } from \"react\";\nimport Rectangle from \"../drawableComponents/Rectangle\";\n\nconst MAX_ZOOM = 4;\nconst MIN_ZOOM = 0.3;\nconst ZOOM_INCREMENT = 0.25;\n\nexport default function Canvas({ objects }) {\n  const [zoom, setZoom] = useState(1.5);\n  const [dragging, setDragging] = useState(false);\n  const [top, setTop] = useState(0);\n  const [left, setLeft] = useState(50);\n  const [relativeTop, setRelativeTop] = useState(0);\n  const [relativeLeft, setRelativeLeft] = useState(0);\n  const [windowWidth, setWindowWidth] = useState(Number(window.innerWidth));\n  const [windowHeight, setWindowHeight] = useState(Number(window.innerHeight));\n\n  const zoomInOutMouseWheel = useCallback((e) => {\n    const newzoom = zoom - e.deltaY * 0.001;\n    setZoom(Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newzoom)));\n  }, [zoom]);\n\n  const mouseDown = useCallback((e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    if (e.button !== 0) {\n      return; // Should only run code from left mouse click\n    }\n    // console.log(\"mouseDown\", e.pageX, e.pageY, e);\n    setDragging(true);\n    setRelativeLeft(e.pageX - left);\n    setRelativeTop(e.pageY - top);\n  }, [left, top]);\n\n  const mouseUp = useCallback((e) => {\n    // console.log(\"mouseUp\");\n    e.stopPropagation();\n    e.preventDefault();\n    setDragging(false);\n  }, []);\n\n  const moveMouse = useCallback((e) => {\n    // console.log(\"moveMouse\");\n    e.stopPropagation();\n    e.preventDefault();\n    if (!dragging) {\n      return;\n    }\n    setLeft(e.pageX - relativeLeft);\n    setTop(e.pageY - relativeTop);\n  }, [dragging]);\n\n  useEffect(() => {\n    // console.log(left, top, dragging);\n\n    document.addEventListener('mousemove', moveMouse);\n    document.addEventListener('mouseup', mouseUp);\n    // window.addEventListener('resize', updateWindowDimensions);\n    return () => {\n      document.removeEventListener('mousemove', moveMouse);\n      document.removeEventListener('mouseup', mouseUp);\n      // window.removeEventListener('resize', updateWindowDimensions);\n    };\n  }, [moveMouse, mouseUp, mouseDown]);\n\n  return (\n    <div className=\"scrollable-image\">\n      <svg className=\"image\"\n        viewBox={`${-left} ${-top} ${windowWidth} ${windowHeight}`}\n        onWheel={zoomInOutMouseWheel}\n        onMouseDown={mouseDown}\n        onMouseUp={mouseUp}\n        onMouseMove={moveMouse}>\n        <g transform={`scale(${zoom})`}>\n          {objects}\n        </g>\n      </svg>\n    </div>\n  );\n}","/Users/abraham/Data-structures-editor/src/utils/TextParser.js",["116","117"],"import { isColor, divideByTokens, isSmaller } from \"./Utils\";\nimport { VERTICAL_DISTANCE, BLOCK_HEIGHT } from \"./Utils\"\n\nimport { Graph } from \"../dataStructures/Graph\";\nimport { Trie } from \"../dataStructures/Trie\";\nimport { Sides, Vector } from \"../dataStructures/Vector\";\nimport { Matrix } from \"../dataStructures/Matrix\";\nimport { Stack } from \"../dataStructures/Stack\";\nimport { Queue } from \"../dataStructures/Queue\";\nimport { Deque } from \"../dataStructures/Deque\";\nimport { Heap, HeapType } from \"../dataStructures/Heap\";\n\nimport { Indices } from \"../dataStructures/Indices\";\nimport { STLIndices } from \"../dataStructures/STLIndices\";\n\nimport { DataStructuresIdentifier } from \"./DataStructuresIdentifier\";\nimport { CppIdentifier } from \"./CppIdentifier\";\n\nexport class TextParser {\n  constructor(text, oldParser = null) {\n    const lines = text.split('\\n').filter((line) => {\n      return line.length > 0;\n    });\n\n    this.textObjects = this.splitInTextObjects(lines);\n\n    this.objects = [];\n    this.lastTop = 0;\n    let objectCount = new Map();\n    this.textObjects.forEach((element, index) => {\n      let object = this.getObject(element, null);\n      this.lastTop += object.height;\n      this.lastTop += VERTICAL_DISTANCE;\n\n      if (element.name) {\n        object.name = element.name;\n      } else {\n        const id = (objectCount.get(object.name) ?? 0) + 1;\n        objectCount.set(object.name, id);\n        object.name += \" \" + id;\n      }\n\n      this.objects.push(object);\n\n      // add indices if is a vector, array or matrix\n      if (DataStructuresIdentifier.isVector(element.type) ||\n        DataStructuresIdentifier.isMatrix(element.type)) {\n        this.objects.push(new Indices(element.type, object));\n      }\n\n      // add top, bottom, front, back if is a stack, queue, deque\n      if (DataStructuresIdentifier.isStack(element.type) ||\n        DataStructuresIdentifier.isQueue(element.type) ||\n        DataStructuresIdentifier.isDeque(element.type) ||\n        DataStructuresIdentifier.isHeap(element.type)) {\n        this.objects.push(new STLIndices(element.type, object));\n      }\n    });\n  }\n\n  getObject(element, previousObject = null) {\n    if (DataStructuresIdentifier.isVector(element.type)) {\n      return this.getVector(element.lines);\n    } else if (DataStructuresIdentifier.isMatrix(element.type)) {\n      return this.getMatrix(element.lines);\n    } else if (DataStructuresIdentifier.isStack(element.type)) {\n      return this.getStack(element.lines);\n    } else if (DataStructuresIdentifier.isQueue(element.type)) {\n      return this.getQueue(element.lines);\n    } else if (DataStructuresIdentifier.isDeque(element.type)) {\n      return this.getDeque(element.lines);\n    } else if (DataStructuresIdentifier.isHeap(element.type)) {\n      return this.getHeap(element.lines);\n    } else if (DataStructuresIdentifier.isGraph(element.type)) {\n      return this.getGraph(element.lines, null);\n    } else if (DataStructuresIdentifier.isTrie(element.type)) {\n      return this.getTrie(element.lines);\n    }\n    return null;\n  }\n\n  getNameIfAny(line) {\n    let tokens = divideByTokens(line);\n    tokens.shift();\n    return tokens.join(\" \");\n  }\n\n  splitInTextObjects(lines) {\n    // Objets are in the form [{ object type, lines of text }]\n    let objects = [];\n    let start = -1;\n    for (let pos = 0; pos <= lines.length; pos++) {\n      if (pos === lines.length || DataStructuresIdentifier.isObject(lines[pos])) {\n        if (start !== -1) {\n          objects.push({\n            type: divideByTokens(lines[start].toLowerCase()).shift(),\n            name: this.getNameIfAny(lines[start]),\n            lines: lines.slice(start + 1, pos).map((line) => {\n              return divideByTokens(line);\n            }),\n          });\n        }\n        start = pos;\n      }\n    }\n    return objects;\n  }\n\n  getVector(lines) {\n    const vector = new Vector(this.lastTop);\n\n    let sortArray = false;\n    let reverseArray = false;\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        vector.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (element === \"sort\") {\n          sortArray = true;\n        } else if (element === \"reverse\") {\n          reverseArray = !reverseArray;\n        } else if (isColor(element)) {\n          // update color of the last element if any\n          vector.updateLastElementColor(element);\n        } else if (CppIdentifier.isPushBack(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPopBack(element)) {\n          vector.popBack();\n        } else {\n          vector.pushBack(element);\n        }\n      }\n    }\n\n    if (sortArray) {\n      vector.data.sort((a, b) => isSmaller(a.value, b.value));\n    }\n\n    if (reverseArray) {\n      vector.data.reverse();\n    }\n\n    return vector;\n  }\n\n  getMatrix(lines) {\n    const matrix = new Matrix(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        matrix.currentColor = line[0];\n        continue;\n      }\n\n      let newRowAdded = false;\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          matrix.updateLastElementColor(element);\n        } else {\n          if (!newRowAdded) {\n            matrix.addRow();\n            newRowAdded = true;\n          }\n          matrix.lastRowPushBack(element);\n        }\n      }\n    }\n\n    if (matrix.empty()) {\n      matrix.height = BLOCK_HEIGHT;\n    }\n\n    return matrix;\n  }\n\n  getQueue(lines) {\n    const queue = new Queue(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        queue.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          queue.updateLastElementColor(element);\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPop(element)) {\n          queue.pop();\n        } else {\n          queue.push(element);\n        }\n      }\n    }\n\n    return queue;\n  }\n\n  getStack(lines) {\n    const stack = new Stack(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        stack.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          stack.updateLastElementColor(element);\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPop(element)) {\n          stack.pop();\n        } else {\n          stack.push(element);\n        }\n      }\n    }\n\n    stack.updateHeight();\n\n    return stack;\n  }\n\n  getDeque(lines) {\n    const deque = new Deque(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        deque.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          deque.updateLastElementColor(element);\n        } else if (CppIdentifier.isPushBack(element)) {\n          deque.side = Sides.BACK;\n        } else if (CppIdentifier.isPushFront(element)) {\n          deque.side = Sides.FRONT;\n        } else if (CppIdentifier.isPopBack(element)) {\n          deque.popBack();\n        } else if (CppIdentifier.isPopFront(element)) {\n          deque.popFront();\n        } else {\n          deque.push(element);\n        }\n      }\n    }\n\n    return deque;\n  }\n\n  getHeap(lines) {\n    const heap = new Heap(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        heap.currentColor = line[0];\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          heap.updateLastElementColor(element);\n        } else if (CppIdentifier.isPop(element)) {\n          heap.pop();\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isMax(element)) {\n          heap.heapType = HeapType.MAX;\n        } else if (CppIdentifier.isMin(element)) {\n          heap.heapType = HeapType.MIN;\n        } else {\n          heap.push(element);\n        }\n      }\n    }\n\n    heap.updateHeight();\n\n    return heap;\n  }\n\n  // getGraph(lines, previousGraph) {\n  //   const graph = new Graph(false, previousGraph);\n\n  //   for (const line of lines) {\n  //     if (line.length === 1) {\n  //       const x = line[0];\n  //       if (isColor(x)) {\n  //         // paint everything that's below with this color\n  //         graph.currentNodeColor = x;\n  //       } else {\n  //         // Single node\n  //         const u = line[0];\n  //         graph.addNode(u, {});\n  //       }\n  //     } else if (line.length === 2) {\n  //       const u = line[0];\n  //       const x = line[1];\n  //       if (isColor(x)) {\n  //         // Node with color x\n  //         graph.addNode(u, { color: x });\n  //       } else {\n  //         // Edge u -> v (depends on the flag)\n  //         const v = line[1];\n  //         graph.addEdge(u, v, \"\");\n  //       }\n  //     } else if (line.length >= 3) {\n  //       const u = line[0];\n  //       const v = line[1];\n\n  //       // Edge u -> v with color | weight | dash\n  //       let weight = \"\";\n  //       let color = \"black\";\n  //       let dashedLine = false;\n  //       for (let i = 2; i < line.length; i++) {\n  //         const x = line[i];\n  //         if (isColor(x)) {\n  //           color = x;\n  //         } else if (isDash(x)) {\n  //           dashedLine = true;\n  //         } else {\n  //           weight += x + \" \";\n  //         }\n  //       }\n\n  //       graph.addEdge(u, v, weight, color, dashedLine);\n  //     }\n  //   }\n\n  //   return graph;\n  // }\n\n  // getTrie(lines) {\n  //   const trie = new Trie(addNode, addEdge);\n  //   currentNodeColor = \"red\";\n  //   for (const line of lines) {\n  //     if (object.length === 1) {\n  //       if (isColor(object[0])) {\n  //         // change the color of all below nodes\n  //         currentNodeColor = object[0];\n  //       } else {\n  //         // insert a word with the currentNodeColor\n  //         const word = object[0];\n  //         trie.insert(word, currentNodeColor);\n  //       }\n  //     } else if (object.length === 2) {\n  //       // insert a word with possibly a custom color\n  //       const word = object[0];\n  //       let color = currentNodeColor;\n  //       if (object.length === 2 && isColor(object[1])) {\n  //         color = object[1];\n  //       }\n  //       trie.insert(word, color);\n  //     }\n  //   }\n  //   trie.dfs(trie.root, \"*\");\n  // }\n}","/Users/abraham/Data-structures-editor/src/utils/DataStructuresIdentifier.js",[],"/Users/abraham/Data-structures-editor/src/utils/CppIdentifier.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Queue.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/EmptyDataStructure.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Deque.js",[],"/Users/abraham/Data-structures-editor/src/drawableComponents/Text.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Indices.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/STLIndices.js",[],"/Users/abraham/Data-structures-editor/src/dataStructures/Heap.js",["118"],"/Users/abraham/Data-structures-editor/src/algorithms/Buchheim.js",["119","120","121","122","123"],"// Reference of the algorithm: https://llimllib.github.io/pymag-trees/\n\nexport const distanceY = 90;\nexport const distanceX = 80;\n\nconst States = {\n  UNVISITED: -1,\n  DFS_TREE: 0,\n  ASSIGN_EXTRA_VARIABLES: 1,\n  APPLY_BUCHHEIM: 2,\n  GET_TREE_RANGE: 3,\n  MOVE_TREE: 4,\n}\n\nfunction findDfsTree(node, parent = undefined, depth = 0) {\n  node.vis = States.DFS_TREE;\n  for (let child of node.children)\n    if (child.vis !== States.DFS_TREE) {\n      node.dfsTreeChildren.push(child);\n      findDfsTree(child, node, depth + 1);\n    }\n}\n\nfunction assign(node, parent = undefined, depth = 0, pos = 1) {\n  node.vis = States.ASSIGN_EXTRA_VARIABLES;\n  node.x = 0;\n  node.y = depth * distanceY;\n  node.parent = parent;\n  node.thread = undefined;\n  node.offset = 0;\n  node.ancestor = node;\n  node.change = 0;\n  node.shift = 0;\n  node.leftmost = undefined;\n  node.pos = pos;\n  let i = 1;\n  for (let child of node.children)\n    if (child.vis !== States.ASSIGN_EXTRA_VARIABLES) {\n      assign(child, node, depth + 1, i++);\n    }\n}\n\nfunction left(node) {\n  return node.thread || (node.children.length && node.children[0]);\n}\n\nfunction right(node) {\n  return node.thread || (node.children.length && node.children[node.children.length - 1]);\n}\n\nfunction leftBrother(node) {\n  if (node.parent === undefined)\n    return undefined;\n  let bro = undefined;\n  for (let child of node.parent.children) {\n    if (child === node) break;\n    bro = child;\n  }\n  return bro;\n}\n\nfunction leftmostSibling(node) {\n  if (node.leftmost === undefined && node.parent && node !== node.parent.children[0]) {\n    node.leftmost = node.parent.children[0];\n  }\n  return node.leftmost;\n}\n\nfunction noChildrenLeft(node) {\n  for (let child of node.children)\n    if (child.vis === States.ASSIGN_EXTRA_VARIABLES)\n      return false;\n  return true;\n}\n\nfunction buchheim(node) {\n  node.vis = States.APPLY_BUCHHEIM;\n  if (noChildrenLeft(node)) {\n    if (leftmostSibling(node)) {\n      node.x = leftBrother(node).x + distanceX;\n    } else {\n      node.x = 0;\n    }\n  } else {\n    let defaultAncestor = node.children[0];\n    for (let child of node.children)\n      if (child.vis !== States.APPLY_BUCHHEIM) {\n        buchheim(child);\n        defaultAncestor = apportion(child, defaultAncestor);\n      }\n    executeShifts(node);\n    const mid = (node.children[0].x + node.children[node.children.length - 1].x) / 2;\n    const bro = leftBrother(node);\n    if (bro) {\n      node.x = bro.x + distanceX;\n      node.offset = node.x - mid;\n    } else {\n      node.x = mid;\n    }\n  }\n}\n\nfunction apportion(node, defaultAncestor) {\n  const w = leftBrother(node);\n  if (w !== undefined && w !== node) {\n    let vir = node;\n    let vor = node;\n    let vil = w;\n    let vol = leftmostSibling(node);\n    let sir = node.offset;\n    let sor = node.offset;\n    let sil = vil.offset;\n    let sol = vol.offset;\n    while (right(vil) && left(vir)) {\n      vil = right(vil);\n      vir = left(vir);\n      vol = left(vol);\n      vor = right(vor);\n      vor.ancestor = node;\n      let shift = (vil.x + sil) - (vir.x + sir) + distanceX;\n      if (shift > 0) {\n        moveSubtree(ancestor(vil, node, defaultAncestor), node, shift);\n        sir = sir + shift;\n        sor = sor + shift;\n      }\n      sil += vil.offset;\n      sir += vir.offset;\n      sol += vol.offset;\n      sor += vor.offset;\n    }\n    if (right(vil) && !right(vor)) {\n      vor.thread = right(vil);\n      vor.offset += sil - sor;\n    } else {\n      if (left(vir) && !left(vol)) {\n        vol.thread = left(vir);\n        vol.offset += sir - sol;\n      }\n      defaultAncestor = node;\n    }\n  }\n  return defaultAncestor;\n}\n\nfunction moveSubtree(wl, wr, shift) {\n  if (wl !== undefined && wr !== undefined) {\n    let subtrees = wr.pos - wl.pos;\n    wr.change -= shift / subtrees;\n    wr.shift += shift;\n    wl.change += shift / subtrees;\n    wr.x += shift;\n    wr.offset += shift;\n  }\n}\n\nfunction executeShifts(node) {\n  let shift = 0;\n  let change = 0;\n  for (let i = node.children.length - 1; i >= 0; i--) {\n    let child = node.children[i];\n    child.x += shift;\n    child.offset += shift;\n    change += child.change;\n    shift += child.shift + change;\n  }\n}\n\nfunction ancestor(vil, node, defaultAncestor) {\n  if (node.parent === undefined)\n    return defaultAncestor;\n  const isChild = node.parent.children.includes((node) => {\n    return node.id === vil.ancestor.id;\n  });\n  return isChild ? vil.ancestor : defaultAncestor;\n}\n\nfunction getTreeRange(node, m = distanceX, depth = 1) {\n  node.x += m;\n  node.vis = States.GET_TREE_RANGE;\n\n  let treeRange = {\n    mn: node.x,\n    mx: node.x\n  };\n\n  for (let child of node.children)\n    if (child.vis !== States.GET_TREE_RANGE) {\n      let childTreeRange = getTreeRange(child, m + node.offset, depth + 1);\n      treeRange.mn = Math.min(treeRange.mn, childTreeRange.mn);\n      treeRange.mx = Math.max(treeRange.mx, childTreeRange.mx);\n    }\n  // console.log(node.id, treeRange);\n\n  return treeRange;\n}\n\nfunction moveTree(node, mn) {\n  node.x += mn;\n  node.vis = States.MOVE_TREE;\n  for (let child of node.children)\n    if (child.vis !== States.MOVE_TREE) {\n      moveTree(child, mn);\n    }\n}\n\nexport function prettify(graph) {\n  const byLabel = (a, b) => {\n    if (a.label < b.label)\n      return -1;\n    if (a.label > b.label)\n      return 1;\n    return 0;\n  }\n\n  // let tmpNodes = [];\n  for (let [node, values] of graph.nodes) {\n    // let index = tmpNodes.push({\n    //   label: values.label,\n    // });\n    graph.nodes.set(node, {\n      ...values,\n      children: [],\n      dfsTreeChildren: [],\n      vis: States.UNVISITED,\n    });\n  }\n\n  // add edges to the tree\n  for (let [edge, values] of graph.edges) {\n    const fromNode = graph.nodes.get(edge.from);\n    const toNode = graph.nodes.get(edge.to);\n    fromNode.children.push(toNode);\n    toNode.children.push(fromNode);\n  }\n\n  // find the dfs tree\n  for (let [node, nodeData] of graph.nodes) {\n    if (nodeData.vis === States.UNVISITED)\n      findDfsTree(nodeData);\n  }\n\n  // change the children with the dfsTreeChildren\n  for (let [node, nodeData] of graph.nodes) {\n    nodeData.children = nodeData.dfsTreeChildren;\n    delete nodeData.dfsTreeChildren;\n  }\n\n  // algorithm of buchheim for a pretty tree\n  let sum = 0;\n  for (let [node, nodeData] of graph.nodes) {\n    if (nodeData.vis === States.DFS_TREE) {\n      assign(nodeData);\n      buchheim(nodeData);\n\n      // define the current tree range\n      let treeRange = getTreeRange(nodeData);\n      let width = treeRange.mx - treeRange.mn;\n      // console.log(treeRange, width);\n\n      if (width >= 0) {\n        moveTree(nodeData, sum);\n        sum += width;\n      }\n      sum += distanceX;\n    }\n  }\n}\n\n// export function getComponentFrom(startingNodeId, nodes, edges) {\n//   addEdgesToTheList(nodes, edges);\n\n//   let component = new Set();\n\n//   function dfs(node) {\n//     component.add(node.id);\n//     node.vis = 1;\n//     for (let child of node.children)\n//       if (child.vis === -1) {\n//         dfs(child);\n//       }\n//   }\n\n//   let startingNode = nodes.find((node) => node.id === startingNodeId);\n//   dfs(startingNode);\n\n//   return component;\n// }",{"ruleId":"124","replacedBy":"125"},{"ruleId":"126","replacedBy":"127"},{"ruleId":"128","severity":1,"message":"129","line":117,"column":6,"nodeType":"130","endLine":117,"endColumn":12,"suggestions":"131"},{"ruleId":"132","severity":1,"message":"133","line":3,"column":10,"nodeType":"134","messageId":"135","endLine":3,"endColumn":16},{"ruleId":"132","severity":1,"message":"136","line":3,"column":53,"nodeType":"134","messageId":"135","endLine":3,"endColumn":59},{"ruleId":"137","severity":1,"message":"138","line":82,"column":22,"nodeType":"139","messageId":"140","endLine":82,"endColumn":23,"suggestions":"141"},{"ruleId":"132","severity":1,"message":"142","line":1,"column":40,"nodeType":"134","messageId":"135","endLine":1,"endColumn":52},{"ruleId":"132","severity":1,"message":"143","line":2,"column":8,"nodeType":"134","messageId":"135","endLine":2,"endColumn":17},{"ruleId":"132","severity":1,"message":"144","line":6,"column":7,"nodeType":"134","messageId":"135","endLine":6,"endColumn":21},{"ruleId":"132","severity":1,"message":"145","line":15,"column":23,"nodeType":"134","messageId":"135","endLine":15,"endColumn":37},{"ruleId":"132","severity":1,"message":"146","line":16,"column":24,"nodeType":"134","messageId":"135","endLine":16,"endColumn":39},{"ruleId":"128","severity":1,"message":"147","line":51,"column":6,"nodeType":"130","endLine":51,"endColumn":16,"suggestions":"148"},{"ruleId":"132","severity":1,"message":"149","line":4,"column":10,"nodeType":"134","messageId":"135","endLine":4,"endColumn":15},{"ruleId":"132","severity":1,"message":"150","line":5,"column":10,"nodeType":"134","messageId":"135","endLine":5,"endColumn":14},{"ruleId":"132","severity":1,"message":"151","line":1,"column":62,"nodeType":"134","messageId":"135","endLine":1,"endColumn":87},{"ruleId":"132","severity":1,"message":"152","line":207,"column":9,"nodeType":"134","messageId":"135","endLine":207,"endColumn":16},{"ruleId":"132","severity":1,"message":"153","line":229,"column":19,"nodeType":"134","messageId":"135","endLine":229,"endColumn":25},{"ruleId":"132","severity":1,"message":"154","line":237,"column":13,"nodeType":"134","messageId":"135","endLine":237,"endColumn":17},{"ruleId":"132","severity":1,"message":"154","line":243,"column":13,"nodeType":"134","messageId":"135","endLine":243,"endColumn":17},{"ruleId":"132","severity":1,"message":"154","line":250,"column":13,"nodeType":"134","messageId":"135","endLine":250,"endColumn":17},"no-native-reassign",["155"],"no-negated-in-lhs",["156"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'parser'. Either include it or remove the dependency array.","ArrayExpression",["157"],"no-unused-vars","'length' is defined but never used.","Identifier","unusedVar","'rotate' is defined but never used.","no-useless-escape","Unnecessary escape character: \\..","Literal","unnecessaryEscape",["158","159"],"'useThrottled' is defined but never used.","'Rectangle' is defined but never used.","'ZOOM_INCREMENT' is assigned a value but never used.","'setWindowWidth' is assigned a value but never used.","'setWindowHeight' is assigned a value but never used.","React Hook useCallback has missing dependencies: 'relativeLeft' and 'relativeTop'. Either include them or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setLeft' needs the current value of 'relativeLeft'.",["160"],"'Graph' is defined but never used.","'Trie' is defined but never used.","'BLOCK_WITH_VERTICAL_SPACE' is defined but never used.","'byLabel' is assigned a value but never used.","'values' is assigned a value but never used.","'node' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"161","fix":"162"},{"messageId":"163","fix":"164","desc":"165"},{"messageId":"166","fix":"167","desc":"168"},{"desc":"169","fix":"170"},"Update the dependencies array to be: [parser, text]",{"range":"171","text":"172"},"removeEscape",{"range":"173","text":"174"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"175","text":"176"},"Replace the `\\` with `\\\\` to include the actual backslash character.","Update the dependencies array to be: [dragging, relativeLeft, relativeTop]",{"range":"177","text":"178"},[2587,2593],"[parser, text]",[1857,1858],"",[1857,1857],"\\",[1609,1619],"[dragging, relativeLeft, relativeTop]"]